// *** WARNING: this file was generated by the Pulumi Kubernetes Istio client generation tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***
import { Input } from '@pulumi/pulumi';
import * as k8s from '@pulumi/kubernetes';
// HINT: @ts-ignore is required otherwise we get a duplicate identifier error

export namespace authentication {
  export namespace v1alpha1 {
    // @ts-ignore
    export interface StringMatch {}
    // @ts-ignore
    export interface MutualTls {
      // Deprecated. Please use mode = PERMISSIVE instead. If set, will translate to `TLS_PERMISSIVE` mode. Set this flag to true to allow regular TLS (i.e without client x509 certificate). If request carries client certificate, identity will be extracted and used (set to peer identity). Otherwise, peer identity will be left unset. When the flag is false (default), request must have client certificate.
      // @ts-ignore
      allowTls?: Input<boolean>;
      // @ts-ignore
      mode?: Input<Mode>;
    }
    // @ts-ignore
    export type Mode = Input<'STRICT' | 'PERMISSIVE'>;
    // @ts-ignore
    export interface Jwt {
      // Identifies the issuer that issued the JWT. See [issuer](https://tools.ietf.org/html/rfc7519#section-4.1.1) Usually a URL or an email address.
      // @ts-ignore
      issuer?: Input<string>;
      // The list of JWT [audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3). that are allowed to access. A JWT containing any of these audiences will be accepted.
      // @ts-ignore
      audiences?: Input<Input<string>[]>;
      // URL of the provider's public key set to validate signature of the JWT. See [OpenID Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
      // @ts-ignore
      jwksUri?: Input<string>;
      // JSON Web Key Set of public keys to validate signature of the JWT. See https://auth0.com/docs/jwks.
      // @ts-ignore
      jwks?: Input<string>;
      // JWT is sent in a request header. `header` represents the header name.
      // @ts-ignore
      jwtHeaders?: Input<Input<string>[]>;
      // JWT is sent in a query parameter. `query` represents the query parameter name.
      // @ts-ignore
      jwtParams?: Input<Input<string>[]>;
      // List of trigger rules to decide if this JWT should be used to validate the request. The JWT validation happens if any one of the rules matched. If the list is not empty and none of the rules matched, authentication will skip the JWT validation. Leave this empty to always trigger the JWT validation.
      // @ts-ignore
      triggerRules?: Input<Input<TriggerRule>[]>;
    }
    // @ts-ignore
    export interface TriggerRule {
      // List of paths to be excluded from the request. The rule is satisfied if request path does not match to any of the path in this list.
      // @ts-ignore
      excludedPaths?: Input<Input<StringMatch>[]>;
      // List of paths that the request must include. If the list is not empty, the rule is satisfied if request path matches at least one of the path in the list. If the list is empty, the rule is ignored, in other words the rule is always satisfied.
      // @ts-ignore
      includedPaths?: Input<Input<StringMatch>[]>;
    }
    // @ts-ignore
    export interface PeerAuthenticationMethod {}
    // @ts-ignore
    export interface OriginAuthenticationMethod {
      // @ts-ignore
      jwt?: Input<Jwt>;
    }
    // @ts-ignore
    export type PrincipalBinding = Input<'USE_PEER' | 'USE_ORIGIN'>;
    export interface PolicyArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<Policy>;
    }
    // @ts-ignore
    export interface Policy {
      // Deprecated. Only mesh-level and namespace-level policies are supported. List rules to select workloads that the policy should be applied on. If empty, policy will be used on all workloads in the same namespace.
      // @ts-ignore
      targets?: Input<Input<TargetSelector>[]>;
      // Deprecated. Please use security/v1beta1/PeerAuthentication instead. List of authentication methods that can be used for peer authentication. They will be evaluated in order; the first validate one will be used to set peer identity (source.user) and other peer attributes. If none of these methods pass, request will be rejected with authentication failed error (401). Leave the list empty if peer authentication is not required
      // @ts-ignore
      peers?: Input<Input<PeerAuthenticationMethod>[]>;
      // Deprecated. Should set mTLS to PERMISSIVE instead. Set this flag to true to accept request (for peer authentication perspective), even when none of the peer authentication methods defined above satisfied. Typically, this is used to delay the rejection decision to next layer (e.g authorization). This flag is ignored if no authentication defined for peer (peers field is empty).
      // @ts-ignore
      peerIsOptional?: Input<boolean>;
      // Deprecated. Please use security/v1beta1/RequestAuthentication instead. List of authentication methods that can be used for origin authentication. Similar to peers, these will be evaluated in order; the first validate one will be used to set origin identity and attributes (i.e request.auth.user, request.auth.issuer etc). If none of these methods pass, request will be rejected with authentication failed error (401). A method may be skipped, depends on its trigger rule. If all of these methods are skipped, origin authentication will be ignored, as if it is not defined. Leave the list empty if origin authentication is not required.
      // @ts-ignore
      origins?: Input<Input<OriginAuthenticationMethod>[]>;
      // Deprecated. Please use security/v1beta1/RequestAuthentication instead. Set this flag to true to accept request (for origin authentication perspective), even when none of the origin authentication methods defined above satisfied. Typically, this is used to delay the rejection decision to next layer (e.g authorization). This flag is ignored if no authentication defined for origin (origins field is empty).
      // @ts-ignore
      originIsOptional?: Input<boolean>;
      // @ts-ignore
      principalBinding?: Input<PrincipalBinding>;
    }
    // @ts-ignore
    export interface TargetSelector {
      // The name must be a short name from the service registry. The fully qualified domain name will be resolved in a platform specific manner.
      // @ts-ignore
      name?: Input<string>;
      // Specifies the ports. Note that this is the port(s) exposed by the service, not workload instance ports. For example, if a service is defined as below, then `8000` should be used, not `9000`. ```yaml kind: Service metadata: ... spec: ports: - name: http port: 8000 targetPort: 9000 selector: app: backend ``` Leave empty to match all ports that are exposed.
      // @ts-ignore
      ports?: Input<Input<PortSelector>[]>;
    }
    // @ts-ignore
    export interface PortSelector {}
  }
}

export namespace common {
  export namespace config {}
}

export namespace mcp {
  export namespace v1alpha1 {
    // @ts-ignore
    export interface SinkNode {
      // An opaque identifier for the MCP node.
      // @ts-ignore
      id?: Input<string>;
      // Opaque annotations extending the node identifier.
      // @ts-ignore
      annotations?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export interface MeshConfigRequest {
      // The version_info provided in the request messages will be the version_info received with the most recent successfully processed response or empty on the first request. It is expected that no new request is sent after a response is received until the client instance is ready to ACK/NACK the new configuration. ACK/NACK takes place by returning the new API config version as applied or the previous API config version respectively. Each type_url (see below) has an independent version associated with it.
      // @ts-ignore
      versionInfo?: Input<string>;
      // @ts-ignore
      sinkNode?: Input<SinkNode>;
      // Type of the resource that is being requested, e.g. "type.googleapis.com/istio.io.networking.v1alpha3.VirtualService".
      // @ts-ignore
      typeUrl?: Input<string>;
      // The nonce corresponding to MeshConfigResponse being ACK/NACKed. See above discussion on version_info and the MeshConfigResponse nonce comment. This may be empty if no nonce is available, e.g. at startup.
      // @ts-ignore
      responseNonce?: Input<string>;
      // @ts-ignore
      errorDetail?: Input<Status>;
    }
    // @ts-ignore
    export interface MeshConfigResponse {
      // The version of the response data.
      // @ts-ignore
      versionInfo?: Input<string>;
      // Type URL for resources wrapped in the provided resources(s). This must be consistent with the type_url in the wrapper messages if resources is non-empty.
      // @ts-ignore
      typeUrl?: Input<string>;
      // The response resources wrapped in the common MCP *Resource* message.
      // @ts-ignore
      resources?: Input<Input<Resource>[]>;
      // The nonce provides a way to explicitly ack a specific MeshConfigResponse in a following MeshConfigRequest. Additional messages may have been sent by client to the management server for the previous version on the stream prior to this MeshConfigResponse, that were unprocessed at response send time. The nonce allows the management server to ignore any further MeshConfigRequests for the previous version until a MeshConfigRequest bearing the nonce.
      // @ts-ignore
      nonce?: Input<string>;
    }
    // @ts-ignore
    export interface Resource {
      // The primary payload for the resource.
      // @ts-ignore
      body?: Input<{ type: Input<string> }>;
      // @ts-ignore
      metadata?: Input<Metadata>;
    }
    // @ts-ignore
    export interface IncrementalMeshConfigRequest {
      // @ts-ignore
      sinkNode?: Input<SinkNode>;
      // Type of the resource that is being requested, e.g. "type.googleapis.com/istio.io.networking.v1alpha3.VirtualService".
      // @ts-ignore
      typeUrl?: Input<string>;
      // When the IncrementalMeshConfigRequest is a ACK or NACK message in response to a previous IncrementalMeshConfigResponse, the response_nonce must be the nonce in the IncrementalMeshConfigResponse. Otherwise response_nonce must be omitted.
      // @ts-ignore
      responseNonce?: Input<string>;
      // @ts-ignore
      errorDetail?: Input<Status>;
      // When the IncrementalMeshConfigRequest is the first in a stream, the initial_resource_versions must be populated. Otherwise, initial_resource_versions must be omitted. The keys are the resources names of the MCP resources known to the MCP client. The values in the map are the associated resource level version info.
      // @ts-ignore
      initialResourceVersions?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export interface IncrementalMeshConfigResponse {
      // The response resources wrapped in the common MCP *Resource* message. These are typed resources that match the type url in the IncrementalMeshConfigRequest.
      // @ts-ignore
      resources?: Input<Input<Resource>[]>;
      // The nonce provides a way for IncrementalMeshConfigRequests to uniquely reference an IncrementalMeshConfigResponse. The nonce is required.
      // @ts-ignore
      nonce?: Input<string>;
      // The version of the response data (used for debugging).
      // @ts-ignore
      systemVersionInfo?: Input<string>;
      // Resources names of resources that have be deleted and to be removed from the MCP Client. Removed resources for missing resources can be ignored.
      // @ts-ignore
      removedResources?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export interface RequestResources {
      // @ts-ignore
      sinkNode?: Input<SinkNode>;
      // When the RequestResources is an ACK or NACK message in response to a previous RequestResources, the response_nonce must be the nonce in the RequestResources. Otherwise response_nonce must be omitted.
      // @ts-ignore
      responseNonce?: Input<string>;
      // @ts-ignore
      errorDetail?: Input<Status>;
      // When the RequestResources is the first in a stream, the initial_resource_versions must be populated. Otherwise, initial_resource_versions must be omitted. The keys are the resources names of the MCP resources known to the MCP client. The values in the map are the associated resource level version info.
      // @ts-ignore
      initialResourceVersions?: Input<Record<Input<string>, Input<string>>>;
      // Type of resource collection that is being requested, e.g.
      // @ts-ignore
      collection?: Input<string>;
      // Request an incremental update for the specified collection. The source may choose to honor this request or ignore and and provide a full-state update in the corresponding `Resource` response.
      // @ts-ignore
      incremental?: Input<boolean>;
    }
    // @ts-ignore
    export interface Resources {
      // The response resources wrapped in the common MCP *Resource* message. These are typed resources that match the type url in the RequestResources message.
      // @ts-ignore
      resources?: Input<Input<Resource>[]>;
      // Required. The nonce provides a way for RequestChange to uniquely reference a RequestResources.
      // @ts-ignore
      nonce: Input<string>;
      // The version of the response data (used for debugging).
      // @ts-ignore
      systemVersionInfo?: Input<string>;
      // Names of resources that have been deleted and to be removed from the MCP sink node. Removed resources for missing resources can be ignored.
      // @ts-ignore
      removedResources?: Input<Input<string>[]>;
      // Type of resource collection that is being requested, e.g.
      // @ts-ignore
      collection?: Input<string>;
      // This resource response is an incremental update. The source should only send incremental updates if the sink requested them.
      // @ts-ignore
      incremental?: Input<boolean>;
    }
    // @ts-ignore
    export interface Metadata {
      // Fully qualified name of the resource. Unique in context of a collection.
      // @ts-ignore
      name?: Input<string>;
      // Map of string keys and values that can be used by source and sink to communicate arbitrary metadata about this resource.
      // @ts-ignore
      annotations?: Input<Record<Input<string>, Input<string>>>;
      // The creation timestamp of the resource.
      // @ts-ignore
      createTime?: Input<string>;
      // Resource version. This is used to determine when resources change across resource updates. It should be treated as opaque by consumers/sinks.
      // @ts-ignore
      version?: Input<string>;
      // Map of string keys and values that can be used to organize and categorize resources within a collection.
      // @ts-ignore
      labels?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export interface Status {
      // The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
      // @ts-ignore
      code?: Input<number>;
      // A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
      // @ts-ignore
      message?: Input<string>;
      // A list of messages that carry the error details. There is a common set of message types for APIs to use.
      // @ts-ignore
      details?: Input<Input<object>[]>;
    }
  }
}

export namespace mesh {
  export namespace v1alpha1 {
    // @ts-ignore
    export interface MeshConfig {
      // @ts-ignore
      localityLbSetting?: Input<LocalityLoadBalancerSetting>;
      // Connection timeout used by Envoy. (MUST BE >=1ms)
      // @ts-ignore
      connectTimeout?: Input<string>;
      // @ts-ignore
      tcpKeepalive?: Input<TcpKeepalive>;
      // @ts-ignore
      h2UpgradePolicy?: Input<H2UpgradePolicy>;
      // @ts-ignore
      outboundTrafficPolicy?: Input<OutboundTrafficPolicy>;
      // Address of the server that will be used by the proxies for policy check calls. By using different names for mixerCheckServer and mixerReportServer, it is possible to have one set of Mixer servers handle policy check calls while another set of Mixer servers handle telemetry calls.
      // @ts-ignore
      mixerCheckServer?: Input<string>;
      // Address of the server that will be used by the proxies for policy report calls.
      // @ts-ignore
      mixerReportServer?: Input<string>;
      // Disable policy checks by the Mixer service. Default is false, i.e. Mixer policy check is enabled by default.
      // @ts-ignore
      disablePolicyChecks?: Input<boolean>;
      // Disable telemetry reporting by the Mixer service for HTTP traffic. Default is false (telemetry reporting via Mixer is enabled). This option provides a transition path for Istio extensibility v2.
      // @ts-ignore
      disableMixerHttpReports?: Input<boolean>;
      // Allow all traffic in cases when the Mixer policy service cannot be reached. Default is false which means the traffic is denied when the client is unable to connect to Mixer.
      // @ts-ignore
      policyCheckFailOpen?: Input<boolean>;
      // Enable session affinity for Envoy Mixer reports so that calls from a proxy will always target the same Mixer instance.
      // @ts-ignore
      sidecarToTelemetrySessionAffinity?: Input<boolean>;
      // Port on which Envoy should listen for incoming connections from other services.
      // @ts-ignore
      proxyListenPort?: Input<number>;
      // Port on which Envoy should listen for HTTP PROXY requests if set.
      // @ts-ignore
      proxyHttpPort?: Input<number>;
      // Automatic protocol detection uses a set of heuristics to determine whether the connection is using TLS or not (on the server side), as well as the application protocol being used (e.g., http vs tcp). These heuristics rely on the client sending the first bits of data. For server first protocols like MySQL, MongoDB, etc., Envoy will timeout on the protocol detection after the specified period, defaulting to non mTLS plain TCP traffic. Set this field to tweak the period that Envoy will wait for the client to send the first bits of data. (MUST BE >=1ms or 0s to disable)
      // @ts-ignore
      protocolDetectionTimeout?: Input<string>;
      // Class of ingress resources to be processed by Istio ingress controller. This corresponds to the value of "kubernetes.io/ingress.class" annotation.
      // @ts-ignore
      ingressClass?: Input<string>;
      // Name of the Kubernetes service used for the istio ingress controller.
      // @ts-ignore
      ingressService?: Input<string>;
      // @ts-ignore
      ingressControllerMode?: Input<IngressControllerMode>;
      // Defines which gateway deployment to use as the Ingress controller. This field corresponds to the Gateway.selector field, and will be set as `istio: INGRESS_SELECTOR`. By default, `ingressgateway` is used, which will select the default IngressGateway as it has the `istio: ingressgateway` labels. It is recommended that this is the same value as ingress_service.
      // @ts-ignore
      ingressSelector?: Input<string>;
      // @ts-ignore
      authPolicy?: Input<AuthPolicy>;
      // @ts-ignore
      rdsRefreshDelay?: Input<string>;
      // Flag to control generation of trace spans and request IDs. Requires a trace span collector defined in the proxy configuration.
      // @ts-ignore
      enableTracing?: Input<boolean>;
      // File address for the proxy access log (e.g. /dev/stdout). Empty value disables access logging.
      // @ts-ignore
      accessLogFile?: Input<string>;
      // Format for the proxy access log Empty value results in proxy's default access log format
      // @ts-ignore
      accessLogFormat?: Input<string>;
      // @ts-ignore
      accessLogEncoding?: Input<AccessLogEncoding>;
      // This flag enables Envoy's gRPC Access Log Service. See [Access Log Service](https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/accesslog/v2/als.proto) for details about Envoy's gRPC Access Log Service API.
      // @ts-ignore
      enableEnvoyAccessLogService?: Input<boolean>;
      // @ts-ignore
      defaultConfig?: Input<ProxyConfig>;
      // @ts-ignore
      mixerAddress?: Input<string>;
      // Enables client side policy checks.
      // @ts-ignore
      enableClientSidePolicyCheck?: Input<boolean>;
      // Unix Domain Socket through which Envoy communicates with NodeAgent SDS to get key/cert for mTLS. Use secret-mount files instead of SDS if set to empty. @deprecated - istio agent will detect and send the path to envoy.
      // @ts-ignore
      sdsUdsPath?: Input<string>;
      // @ts-ignore
      sdsRefreshDelay?: Input<string>;
      // ConfigSource describes a source of configuration data for networking rules, and other Istio configuration artifacts. Multiple data sources can be configured for a single control plane.
      // @ts-ignore
      configSources?: Input<Input<ConfigSource>[]>;
      // This flag is used to enable mutual TLS automatically for service to service communication within the mesh, default false. If set to true, and a given service does not have a corresponding DestinationRule configured, or its DestinationRule does not have ClientTLSSettings specified, Istio configures client side TLS configuration appropriately. More specifically, If the upstream authentication policy is in STRICT mode, use Istio provisioned certificate for mutual TLS to connect to upstream. If upstream service is in plain text mode, use plain text. If the upstream authentication policy is in PERMISSIVE mode, Istio configures clients to use mutual TLS when server sides are capable of accepting mutual TLS traffic. If service DestinationRule exists and has ClientTLSSettings specified, that is always used instead.
      // @ts-ignore
      enableAutoMtls?: Input<boolean>;
      // This flag is used by secret discovery service(SDS). If set to true ([prerequisite](https://kubernetes.io/docs/concepts/storage/volumes/#projected)), Istio will inject volumes mount for Kubernetes service account trustworthy JWT(which is available with Kubernetes 1.12 or higher), so that the Kubernetes API server mounts Kubernetes service account trustworthy JWT to the Envoy container, which will be used to request key/cert eventually. This isn't supported for non-Kubernetes cases.
      // @ts-ignore
      enableSdsTokenMount?: Input<boolean>;
      // This flag is used by secret discovery service(SDS). If set to true, Envoy will fetch a normal Kubernetes service account JWT from '/var/run/secrets/kubernetes.io/serviceaccount/token' (https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/#accessing-the-api-from-a-pod) and pass to sds server, which will be used to request key/cert eventually. If both enable_sds_token_mount and sds_use_k8s_sa_jwt are set to true, enable_sds_token_mount(trustworthy jwt) takes precedence. This isn't supported for non-k8s case.
      // @ts-ignore
      sdsUseK8sSaJwt?: Input<boolean>;
      // The trust domain corresponds to the trust root of a system. Refer to [SPIFFE-ID](https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE-ID.md#21-trust-domain)
      // @ts-ignore
      trustDomain?: Input<string>;
      // The trust domain aliases represent the aliases of `trust_domain`. For example, if we have ```yaml trustDomain: td1 trustDomainAliases: ["td2", "td3"] ``` Any service with the identity `td1/ns/foo/sa/a-service-account`, `td2/ns/foo/sa/a-service-account`, or `td3/ns/foo/sa/a-service-account` will be treated the same in the Istio mesh.
      // @ts-ignore
      trustDomainAliases?: Input<Input<string>[]>;
      // The default value for the ServiceEntry.export_to field and services imported through container registry integrations, e.g. this applies to Kubernetes Service resources. The value is a list of namespace names and reserved namespace aliases. The allowed namespace aliases are: * - All Namespaces . - Current Namespace ~ - No Namespace
      // @ts-ignore
      defaultServiceExportTo?: Input<Input<string>[]>;
      // The default value for the VirtualService.export_to field. Has the same syntax as 'default_service_export_to'.
      // @ts-ignore
      defaultVirtualServiceExportTo?: Input<Input<string>[]>;
      // The default value for the DestinationRule.export_to field. Has the same syntax as 'default_service_export_to'.
      // @ts-ignore
      defaultDestinationRuleExportTo?: Input<Input<string>[]>;
      // The namespace to treat as the administrative root namespace for Istio configuration. When processing a leaf namespace Istio will search for declarations in that namespace first and if none are found it will search in the root namespace. Any matching declaration found in the root namespace is processed as if it were declared in the leaf namespace.
      // @ts-ignore
      rootNamespace?: Input<string>;
      // Configures DNS refresh rate for Envoy clusters of type STRICT_DNS
      // @ts-ignore
      dnsRefreshRate?: Input<string>;
      // The flag to disable report batch.
      // @ts-ignore
      disableReportBatch?: Input<boolean>;
      // When disable_report_batch is false, this value specifies the maximum number of requests that are batched in report. If left unspecified, the default value of report_batch_max_entries == 0 will use the hardcoded defaults of istio::mixerclient::ReportOptions.
      // @ts-ignore
      reportBatchMaxEntries?: Input<number>;
      // When disable_report_batch is false, this value specifies the maximum elapsed time a batched report will be sent after a user request is processed. If left unspecified, the default report_batch_max_time == 0 will use the hardcoded defaults of istio::mixerclient::ReportOptions.
      // @ts-ignore
      reportBatchMaxTime?: Input<string>;
      // Name to be used while emitting statistics for inbound clusters. The same pattern is used while computing stat prefix for network filters like TCP and Redis. By default, Istio emits statistics with the pattern `inbound|<port>|<port-name>|<service-FQDN>`. For example `inbound|7443|grpc-reviews|reviews.prod.svc.cluster.local`. This can be used to override that pattern.
      // @ts-ignore
      inboundClusterStatName?: Input<string>;
      // Name to be used while emitting statistics for outbound clusters. The same pattern is used while computing stat prefix for network filters like TCP and Redis. By default, Istio emits statistics with the pattern `outbound|<port>|<subsetname>|<service-FQDN>`. For example `outbound|8080|v2|reviews.prod.svc.cluster.local`. This can be used to override that pattern.
      // @ts-ignore
      outboundClusterStatName?: Input<string>;
      // Configure the provision of certificates.
      // @ts-ignore
      certificates?: Input<Input<Certificate>[]>;
      // @ts-ignore
      thriftConfig?: Input<ThriftConfig>;
      // Settings to be applied to select services.
      // @ts-ignore
      serviceSettings?: Input<Input<ServiceSettings>[]>;
      // If enabled, Istio agent will merge metrics exposed by the application with metrics from Envoy and Istio agent. The sidecar injection will replace `prometheus.io` annotations present on the pod and redirect them towards Istio agent, which will then merge metrics of from the application with Istio metrics. This relies on the annotations `prometheus.io/scrape`, `prometheus.io/port`, and `prometheus.io/path` annotations. If you are running a separately managed Envoy with an Istio sidecar, this may cause issues, as the metrics will collide. In this case, it is recommended to disable aggregation on that deployment with the `prometheus.istio.io/merge-metrics: "false"` annotation. If not specified, this will be enabled by default.
      // @ts-ignore
      enablePrometheusMerge?: Input<boolean>;
    }
    // @ts-ignore
    export type IngressControllerMode = Input<'UNSPECIFIED' | 'OFF' | 'DEFAULT' | 'STRICT'>;
    // @ts-ignore
    export type AuthPolicy = Input<'NONE' | 'MUTUAL_TLS'>;
    // @ts-ignore
    export type AccessLogEncoding = Input<'TEXT' | 'JSON'>;
    // @ts-ignore
    export interface ProxyConfig {
      // Path to the generated configuration file directory. Proxy agent generates the actual configuration and stores it in this directory.
      // @ts-ignore
      configPath?: Input<string>;
      // Path to the proxy binary
      // @ts-ignore
      binaryPath?: Input<string>;
      // Service cluster defines the name for the service_cluster that is shared by all Envoy instances. This setting corresponds to _--service-cluster_ flag in Envoy. In a typical Envoy deployment, the _service-cluster_ flag is used to identify the caller, for source-based routing scenarios.
      // @ts-ignore
      serviceCluster?: Input<string>;
      // The time in seconds that Envoy will drain connections during a hot restart. MUST be >=1s (e.g., _1s/1m/1h_)
      // @ts-ignore
      drainDuration?: Input<string>;
      // The time in seconds that Envoy will wait before shutting down the parent process during a hot restart. MUST be >=1s (e.g., _1s/1m/1h_). MUST BE greater than _drain_duration_ parameter.
      // @ts-ignore
      parentShutdownDuration?: Input<string>;
      // Address of the discovery service exposing xDS with mTLS connection. The inject configuration may override this value.
      // @ts-ignore
      discoveryAddress?: Input<string>;
      // @ts-ignore
      discoveryRefreshDelay?: Input<string>;
      // Address of the Zipkin service (e.g. _zipkin:9411_). DEPRECATED: Use [tracing][istio.mesh.v1alpha1.ProxyConfig.tracing] instead.
      // @ts-ignore
      zipkinAddress?: Input<string>;
      // IP Address and Port of a statsd UDP listener (e.g. _10.75.241.127:9125_).
      // @ts-ignore
      statsdUdpAddress?: Input<string>;
      // @ts-ignore
      envoyMetricsServiceAddress?: Input<string>;
      // Port on which Envoy should listen for administrative commands.
      // @ts-ignore
      proxyAdminPort?: Input<number>;
      // @ts-ignore
      availabilityZone?: Input<string>;
      // @ts-ignore
      controlPlaneAuthPolicy?: Input<AuthenticationPolicy>;
      // File path of custom proxy configuration, currently used by proxies in front of Mixer and Pilot.
      // @ts-ignore
      customConfigFile?: Input<string>;
      // Maximum length of name field in Envoy's metrics. The length of the name field is determined by the length of a name field in a service and the set of labels that comprise a particular version of the service. The default value is set to 189 characters. Envoy's internal metrics take up 67 characters, for a total of 256 character name per metric. Increase the value of this field if you find that the metrics from Envoys are truncated.
      // @ts-ignore
      statNameLength?: Input<number>;
      // The number of worker threads to run. If unset, this will be automatically determined based on CPU requests/limits. If set to 0, all cores on the machine will be used.
      // @ts-ignore
      concurrency?: Input<number>;
      // Path to the proxy bootstrap template file
      // @ts-ignore
      proxyBootstrapTemplatePath?: Input<string>;
      // @ts-ignore
      interceptionMode?: Input<InboundInterceptionMode>;
      // @ts-ignore
      tracing?: Input<Tracing>;
      // @ts-ignore
      sds?: Input<SDS>;
      // @ts-ignore
      envoyAccessLogService?: Input<RemoteService>;
      // @ts-ignore
      envoyMetricsService?: Input<RemoteService>;
      // Additional env variables for the proxy. Names starting with ISTIO_META_ will be included in the generated bootstrap and sent to the XDS server.
      // @ts-ignore
      proxyMetadata?: Input<Record<Input<string>, Input<string>>>;
      // Port on which the agent should listen for administrative commands such as readiness probe.
      // @ts-ignore
      statusPort?: Input<number>;
      // An additional list of tags to extract from the in-proxy Istio telemetry. These extra tags can be added by configuring the telemetry extension. Each additional tag needs to be present in this list. Extra tags emitted by the telemetry extensions must be listed here so that they can be processed and exposed as Prometheus metrics.
      // @ts-ignore
      extraStatTags?: Input<Input<string>[]>;
      // @ts-ignore
      gatewayTopology?: Input<Topology>;
    }
    // @ts-ignore
    export interface OutboundTrafficPolicy {
      // @ts-ignore
      mode?: Input<Mode>;
    }
    // @ts-ignore
    export interface ConfigSource {
      // Address of the server implementing the Istio Mesh Configuration protocol (MCP). Can be IP address or a fully qualified DNS name. Use fs:/// to specify a file-based backend with absolute path to the directory.
      // @ts-ignore
      address?: Input<string>;
      // @ts-ignore
      tlsSettings?: Input<ClientTLSSettings>;
      // Describes the source of configuration, if nothing is specified default is MCP
      // @ts-ignore
      subscribedResources?: Input<Input<Resource>[]>;
    }
    // @ts-ignore
    export type H2UpgradePolicy = Input<'DO_NOT_UPGRADE' | 'UPGRADE'>;
    // @ts-ignore
    export interface Certificate {
      // Name of the secret the certificate and its key will be stored into. If it is empty, it will not be stored into a secret. Instead, the certificate and its key will be stored into a hard-coded directory.
      // @ts-ignore
      secretName?: Input<string>;
      // The DNS names for the certificate. A certificate may contain multiple DNS names.
      // @ts-ignore
      dnsNames?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export interface ThriftConfig {
      // Specify thrift rate limit service URL. If pilot has thrift protocol support enabled, this will enable the rate limit service for destinations that have matching rate limit configurations.
      // @ts-ignore
      rateLimitUrl?: Input<string>;
      // Specify thrift rate limit service timeout, in milliseconds. Default is 50ms
      // @ts-ignore
      rateLimitTimeout?: Input<string>;
    }
    // @ts-ignore
    export interface ServiceSettings {
      // The services to which the Settings should be applied. Services are selected using the hostname matching rules used by DestinationRule.
      // @ts-ignore
      hosts?: Input<Input<string>[]>;
      // @ts-ignore
      settings?: Input<Settings>;
    }
    // @ts-ignore
    export type Mode = Input<'REGISTRY_ONLY' | 'ALLOW_ANY'>;
    // @ts-ignore
    export interface Settings {
      // If true, specifies that the client and service endpoints must reside in the same cluster. By default, in multi-cluster deployments, the Istio control plane assumes all service endpoints to be reachable from any client in any of the clusters which are part of the mesh. This configuration option limits the set of service endpoints visible to a client to be cluster scoped.
      // @ts-ignore
      clusterLocal?: Input<boolean>;
    }
    // @ts-ignore
    export type Resource = Input<'SERVICE_REGISTRY'>;
    // @ts-ignore
    export interface Network {
      // The list of endpoints in the network (obtained through the constituent service registries or from CIDR ranges). All endpoints in the network are directly accessible to one another.
      // @ts-ignore
      endpoints?: Input<Input<NetworkEndpoints>[]>;
      // Set of gateways associated with the network.
      // @ts-ignore
      gateways?: Input<Input<IstioNetworkGateway>[]>;
    }
    // @ts-ignore
    export interface NetworkEndpoints {}
    // @ts-ignore
    export interface IstioNetworkGateway {
      // The port associated with the gateway.
      // @ts-ignore
      port?: Input<number>;
      // The locality associated with an explicitly specified gateway (i.e. ip)
      // @ts-ignore
      locality?: Input<string>;
    }
    // @ts-ignore
    export interface MeshNetworks {
      // The set of networks inside this mesh. Each network should have a unique name and information about how to infer the endpoints in the network as well as the gateways associated with the network.
      // @ts-ignore
      networks?: Input<Record<Input<string>, Input<Network>>>;
    }
    // @ts-ignore
    export type AuthenticationPolicy = Input<'NONE' | 'MUTUAL_TLS' | 'INHERIT'>;
    // @ts-ignore
    export interface Tracing {
      // @ts-ignore
      tlsSettings?: Input<ClientTLSSettings>;
      // Configures the custom tags to be added to active span by all proxies (i.e. sidecars and gateways). The key represents the name of the tag. Ex: ```yaml custom_tags: new_tag_name: header: name: custom-http-header-name default_value: defaulted-value-from-custom-header ``` $hide_from_docs
      // @ts-ignore
      customTags?: Input<Record<Input<string>, Input<CustomTag>>>;
      // Configures the maximum length of the request path to extract and include in the HttpUrl tag. Used to truncate length request paths to meet the needs of tracing backend. If not set, then a length of 256 will be used. $hide_from_docs
      // @ts-ignore
      maxPathTagLength?: Input<number>;
      // The percentage of requests (0.0 - 100.0) that will be randomly selected for trace generation, if not requested by the client or not forced. Default is 100. $hide_from_docs
      // @ts-ignore
      sampling?: Input<number>;
    }
    // @ts-ignore
    export interface CustomTag {}
    // @ts-ignore
    export interface Zipkin {
      // Address of the Zipkin service (e.g. _zipkin:9411_).
      // @ts-ignore
      address?: Input<string>;
    }
    // @ts-ignore
    export interface Lightstep {
      // Address of the Lightstep Satellite pool.
      // @ts-ignore
      address?: Input<string>;
      // The Lightstep access token.
      // @ts-ignore
      accessToken?: Input<string>;
    }
    // @ts-ignore
    export interface Datadog {
      // Address of the Datadog Agent.
      // @ts-ignore
      address?: Input<string>;
    }
    // @ts-ignore
    export interface Stackdriver {
      // debug enables trace output to stdout. $hide_from_docs
      // @ts-ignore
      debug?: Input<boolean>;
      // The global default max number of attributes per span. default is 200. $hide_from_docs
      // @ts-ignore
      maxNumberOfAttributes?: Input<number>;
      // The global default max number of annotation events per span. default is 200. $hide_from_docs
      // @ts-ignore
      maxNumberOfAnnotations?: Input<number>;
      // The global default max number of message events per span. default is 200. $hide_from_docs
      // @ts-ignore
      maxNumberOfMessageEvents?: Input<number>;
    }
    // @ts-ignore
    export interface Literal {
      // Static literal value used to populate the tag value.
      // @ts-ignore
      value?: Input<string>;
    }
    // @ts-ignore
    export interface Environment {
      // Name of the environment variable used to populate the tag's value
      // @ts-ignore
      name?: Input<string>;
      // When the environment variable is not found, the tag's value will be populated with this default value if specified, otherwise the tag will not be populated.
      // @ts-ignore
      defaultValue?: Input<string>;
    }
    // @ts-ignore
    export interface RequestHeader {
      // HTTP header name used to obtain the value from to populate the tag value.
      // @ts-ignore
      name?: Input<string>;
      // Default value to be used for the tag when the named HTTP header does not exist. The tag will be skipped if no default value is provided.
      // @ts-ignore
      defaultValue?: Input<string>;
    }
    // @ts-ignore
    export interface SDS {
      // True if SDS is enabled.
      // @ts-ignore
      enabled?: Input<boolean>;
      // Path of k8s service account JWT path.
      // @ts-ignore
      k8sSaJwtPath?: Input<string>;
    }
    // @ts-ignore
    export interface Topology {
      // Number of trusted proxies deployed in front of the Istio gateway proxy. When this option is set to value N greater than zero, the trusted client address is assumed to be the Nth address from the right end of the X-Forwarded-For (XFF) header from the incoming request. If the X-Forwarded-For (XFF) header is missing or has fewer than N addresses, the gateway proxy falls back to using the immediate downstream connection's source address as the trusted client address. Note that the gateway proxy will append the downstream connection's source address to the X-Forwarded-For (XFF) address and set the X-Envoy-External-Address header to the trusted client address before forwarding it to the upstream services in the cluster. The default value of num_trusted_proxies is 0. See [Envoy XFF] (https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_conn_man/headers#config-http-conn-man-headers-x-forwarded-for) header handling for more details.
      // @ts-ignore
      numTrustedProxies?: Input<number>;
      // @ts-ignore
      forwardClientCertDetails?: Input<ForwardClientCertDetails>;
    }
    // @ts-ignore
    export type ForwardClientCertDetails = Input<
      'UNDEFINED' | 'SANITIZE' | 'FORWARD_ONLY' | 'APPEND_FORWARD' | 'SANITIZE_SET' | 'ALWAYS_FORWARD_ONLY'
    >;
    // @ts-ignore
    export type InboundInterceptionMode = Input<'REDIRECT' | 'TPROXY'>;
    // @ts-ignore
    export interface RemoteService {
      // @ts-ignore
      tcpKeepalive?: Input<TcpKeepalive>;
      // Address of a remove service used for various purposes (access log receiver, metrics receiver, etc.). Can be IP address or a fully qualified DNS name.
      // @ts-ignore
      address?: Input<string>;
      // @ts-ignore
      tlsSettings?: Input<ClientTLSSettings>;
    }
    // @ts-ignore
    export interface ClientTLSSettings {
      // @ts-ignore
      mode?: Input<TLSmode>;
      // REQUIRED if mode is `MUTUAL`. The path to the file holding the client-side TLS certificate to use. Should be empty if mode is `ISTIO_MUTUAL`.
      // @ts-ignore
      clientCertificate: Input<string>;
      // REQUIRED if mode is `MUTUAL`. The path to the file holding the client's private key. Should be empty if mode is `ISTIO_MUTUAL`.
      // @ts-ignore
      privateKey: Input<string>;
      // OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate. If omitted, the proxy will not verify the server's certificate. Should be empty if mode is `ISTIO_MUTUAL`.
      // @ts-ignore
      caCertificates?: Input<string>;
      // A list of alternate names to verify the subject identity in the certificate. If specified, the proxy will verify that the server certificate's subject alt name matches one of the specified values. If specified, this list overrides the value of subject_alt_names from the ServiceEntry.
      // @ts-ignore
      subjectAltNames?: Input<Input<string>[]>;
      // SNI string to present to the server during TLS handshake.
      // @ts-ignore
      sni?: Input<string>;
    }
    // @ts-ignore
    export interface TcpKeepalive {
      // The time duration a connection needs to be idle before keep-alive probes start being sent. Default is to use the OS level configuration (unless overridden, Linux defaults to 7200s (ie 2 hours.)
      // @ts-ignore
      time?: Input<string>;
      // Maximum number of keepalive probes to send without response before deciding the connection is dead. Default is to use the OS level configuration (unless overridden, Linux defaults to 9.)
      // @ts-ignore
      probes?: Input<number>;
      // The time duration between keep-alive probes. Default is to use the OS level configuration (unless overridden, Linux defaults to 75s.)
      // @ts-ignore
      interval?: Input<string>;
    }
    // @ts-ignore
    export interface LocalityLoadBalancerSetting {
      // Optional: only one of distribute or failover can be set. Explicitly specify loadbalancing weight across different zones and geographical locations. Refer to [Locality weighted load balancing](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/locality_weight) If empty, the locality weight is set according to the endpoints number within it.
      // @ts-ignore
      distribute?: Input<Input<Distribute>[]>;
      // Optional: only failover or distribute can be set. Explicitly specify the region traffic will land on when endpoints in local region becomes unhealthy. Should be used together with OutlierDetection to detect unhealthy endpoints. Note: if no OutlierDetection specified, this will not take effect.
      // @ts-ignore
      failover?: Input<Input<Failover>[]>;
      // enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety. e.g. true means that turn on locality load balancing for this DestinationRule no matter what mesh wide settings is.
      // @ts-ignore
      enabled?: Input<boolean>;
    }
    // @ts-ignore
    export type TLSmode = Input<'DISABLE' | 'SIMPLE' | 'MUTUAL' | 'ISTIO_MUTUAL'>;
    // @ts-ignore
    export interface Distribute {
      // Originating locality, '/' separated, e.g. 'region/zone/sub_zone'.
      // @ts-ignore
      from?: Input<string>;
      // Map of upstream localities to traffic distribution weights. The sum of all weights should be == 100. Any locality not assigned a weight will receive no traffic.
      // @ts-ignore
      to?: Input<Record<Input<string>, Input<number>>>;
    }
    // @ts-ignore
    export interface Failover {
      // Originating region.
      // @ts-ignore
      from?: Input<string>;
      // Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
      // @ts-ignore
      to?: Input<string>;
    }
  }
}

export namespace mixer {
  export namespace v1 {
    // @ts-ignore
    export interface Attributes {
      // A map of attribute name to its value.
      // @ts-ignore
      attributes?: Input<Record<Input<string>, Input<AttributeValue>>>;
    }
    // @ts-ignore
    export interface AttributeValue {}
    // @ts-ignore
    export interface StringMap {
      // Holds a set of name/value pairs.
      // @ts-ignore
      entries?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export interface CompressedAttributes {
      // Holds attributes of type STRING, DNS_NAME, EMAIL_ADDRESS, URI
      // @ts-ignore
      strings?: Input<Record<Input<string>, Input<number>>>;
      // Holds attributes of type BYTES
      // @ts-ignore
      bytes?: Input<Record<Input<string>, Input<string>>>;
      // The message-level dictionary.
      // @ts-ignore
      words?: Input<Input<string>[]>;
      // Holds attributes of type INT64
      // @ts-ignore
      int64s?: Input<Record<Input<string>, Input<number>>>;
      // Holds attributes of type DOUBLE
      // @ts-ignore
      doubles?: Input<Record<Input<string>, Input<number>>>;
      // Holds attributes of type BOOL
      // @ts-ignore
      bools?: Input<Record<Input<string>, Input<boolean>>>;
      // Holds attributes of type TIMESTAMP
      // @ts-ignore
      timestamps?: Input<Record<Input<string>, Input<string>>>;
      // Holds attributes of type DURATION
      // @ts-ignore
      durations?: Input<Record<Input<string>, Input<string>>>;
      // Holds attributes of type STRING_MAP
      // @ts-ignore
      stringMaps?: Input<Record<Input<string>, Input<StringMap>>>;
    }
    // @ts-ignore
    export interface StringMap {
      // Holds a set of name/value pairs.
      // @ts-ignore
      entries?: Input<Record<Input<string>, Input<number>>>;
    }
    // @ts-ignore
    export interface CheckRequest {
      // @ts-ignore
      attributes?: Input<CompressedAttributes>;
      // The number of words in the global dictionary, used with to populate the attributes. This value is used as a quick way to determine whether the client is using a dictionary that the server understands.
      // @ts-ignore
      globalWordCount?: Input<number>;
      // Used for deduplicating `Check` calls in the case of failed RPCs and retries. This should be a UUID per call, where the same UUID is used for retries of the same call.
      // @ts-ignore
      deduplicationId?: Input<string>;
      // The individual quotas to allocate
      // @ts-ignore
      quotas?: Input<Record<Input<string>, Input<QuotaParams>>>;
    }
    // @ts-ignore
    export interface QuotaParams {
      // Amount of quota to allocate
      // @ts-ignore
      amount?: Input<number>;
      // When true, supports returning less quota than what was requested.
      // @ts-ignore
      bestEffort?: Input<boolean>;
    }
    // @ts-ignore
    export interface CheckResponse {
      // The resulting quota, one entry per requested quota.
      // @ts-ignore
      quotas?: Input<Record<Input<string>, Input<QuotaResult>>>;
      // @ts-ignore
      precondition?: Input<PreconditionResult>;
    }
    // @ts-ignore
    export interface PreconditionResult {
      // @ts-ignore
      status?: Input<Status>;
      // The amount of time for which this result can be considered valid.
      // @ts-ignore
      validDuration?: Input<string>;
      // The number of uses for which this result can be considered valid.
      // @ts-ignore
      validUseCount?: Input<number>;
      // @ts-ignore
      referencedAttributes?: Input<ReferencedAttributes>;
      // @ts-ignore
      routeDirective?: Input<RouteDirective>;
    }
    // @ts-ignore
    export interface QuotaResult {
      // @ts-ignore
      status?: Input<Status>;
      // The amount of time for which this result can be considered valid.
      // @ts-ignore
      validDuration?: Input<string>;
      // @ts-ignore
      referencedAttributes?: Input<ReferencedAttributes>;
      // The amount of granted quota. When `QuotaParams.best_effort` is true, this will be >= 0. If `QuotaParams.best_effort` is false, this will be either 0 or >= `QuotaParams.amount`.
      // @ts-ignore
      grantedAmount?: Input<number>;
    }
    // @ts-ignore
    export interface ReferencedAttributes {
      // The message-level dictionary. Refer to [CompressedAttributes][istio.mixer.v1.CompressedAttributes] for information on using dictionaries.
      // @ts-ignore
      words?: Input<Input<string>[]>;
      // Describes a set of attributes.
      // @ts-ignore
      attributeMatches?: Input<Input<AttributeMatch>[]>;
    }
    // @ts-ignore
    export interface RouteDirective {
      // Operations on the request headers.
      // @ts-ignore
      requestHeaderOperations?: Input<Input<HeaderOperation>[]>;
      // Operations on the response headers.
      // @ts-ignore
      responseHeaderOperations?: Input<Input<HeaderOperation>[]>;
      // If set, enables a direct response without proxying the request to the routing destination. Required to be a value in the 2xx or 3xx range.
      // @ts-ignore
      directResponseCode?: Input<number>;
      // Supplies the response body for the direct response. If this setting is omitted, no body is included in the generated response.
      // @ts-ignore
      directResponseBody?: Input<string>;
    }
    // @ts-ignore
    export interface AttributeMatch {
      // The name of the attribute. This is a dictionary index encoded in a manner identical to all strings in the [CompressedAttributes][istio.mixer.v1.CompressedAttributes] message.
      // @ts-ignore
      name?: Input<number>;
      // @ts-ignore
      condition?: Input<Condition>;
      // If a REGEX condition is provided for a STRING_MAP attribute, clients should use the regex value to match against map keys. RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
      // @ts-ignore
      regex?: Input<string>;
      // A key in a STRING_MAP. When multiple keys from a STRING_MAP attribute were referenced, there will be multiple AttributeMatch messages with different map_key values. Values for map_key SHOULD be ignored for attributes that are not STRING_MAP.
      // @ts-ignore
      mapKey?: Input<number>;
    }
    // @ts-ignore
    export type Condition = Input<'CONDITION_UNSPECIFIED' | 'ABSENCE' | 'EXACT' | 'REGEX'>;
    // @ts-ignore
    export interface HeaderOperation {
      // Header name.
      // @ts-ignore
      name?: Input<string>;
      // Header value.
      // @ts-ignore
      value?: Input<string>;
      // @ts-ignore
      operation?: Input<Operation>;
    }
    // @ts-ignore
    export type Operation = Input<'REPLACE' | 'REMOVE' | 'APPEND'>;
    // @ts-ignore
    export interface ReportRequest {
      // next value: 5
      // @ts-ignore
      attributes?: Input<Input<CompressedAttributes>[]>;
      // The number of words in the global dictionary. To detect global dictionary out of sync between client and server.
      // @ts-ignore
      globalWordCount?: Input<number>;
      // @ts-ignore
      repeatedAttributesSemantics?: Input<RepeatedAttributesSemantics>;
      // The default message-level dictionary for all the attributes. Individual attribute messages can have their own dictionaries, but if they don't then this set of words, if it is provided, is used instead.
      // @ts-ignore
      defaultWords?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export type RepeatedAttributesSemantics = Input<'DELTA_ENCODING' | 'INDEPENDENT_ENCODING'>;
    // @ts-ignore
    export interface ReportResponse {}
    // @ts-ignore
    export interface Status {
      // The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
      // @ts-ignore
      code?: Input<number>;
      // A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client.
      // @ts-ignore
      message?: Input<string>;
      // A list of messages that carry the error details. There is a common set of message types for APIs to use.
      // @ts-ignore
      details?: Input<Input<object>[]>;
    }
    export interface HTTPAPISpecArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<HTTPAPISpec>;
    }
    // @ts-ignore
    export interface HTTPAPISpec {
      // @ts-ignore
      attributes?: Input<Attributes>;
      // List of HTTP patterns to match.
      // @ts-ignore
      patterns?: Input<Input<HTTPAPISpecPattern>[]>;
      // List of APIKey that describes how to extract an API-KEY from an HTTP request. The first API-Key match found in the list is used, i.e. 'OR' semantics.
      // @ts-ignore
      apiKeys?: Input<Input<APIKey>[]>;
    }
    // @ts-ignore
    export interface HTTPAPISpecPattern {
      // @ts-ignore
      attributes?: Input<Attributes>;
      // HTTP request method to match against as defined by [rfc7231](https://tools.ietf.org/html/rfc7231#page-21). For example: GET, HEAD, POST, PUT, DELETE.
      // @ts-ignore
      httpMethod?: Input<string>;
    }
    // @ts-ignore
    export interface APIKey {}
    // @ts-ignore
    export interface HTTPAPISpecReference {
      // The short name of the HTTPAPISpec. This is the resource name defined by the metadata name field.
      // @ts-ignore
      name?: Input<string>;
      // Optional namespace of the HTTPAPISpec. Defaults to the encompassing HTTPAPISpecBinding's metadata namespace field.
      // @ts-ignore
      namespace?: Input<string>;
    }
    export interface HTTPAPISpecBindingArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<HTTPAPISpecBinding>;
    }
    // @ts-ignore
    export interface HTTPAPISpecBinding {
      // One or more services to map the listed HTTPAPISpec onto.
      // @ts-ignore
      services?: Input<Input<IstioService>[]>;
      // One or more HTTPAPISpec references that should be mapped to the specified service(s). The aggregate collection of match conditions defined in the HTTPAPISpecs should not overlap.
      // @ts-ignore
      apiSpecs?: Input<Input<HTTPAPISpecReference>[]>;
    }
    // @ts-ignore
    export interface IstioService {
      // The short name of the service such as "foo".
      // @ts-ignore
      name?: Input<string>;
      // Optional namespace of the service. Defaults to value of metadata namespace field.
      // @ts-ignore
      namespace?: Input<string>;
      // Domain suffix used to construct the service FQDN in implementations that support such specification.
      // @ts-ignore
      domain?: Input<string>;
      // The service FQDN.
      // @ts-ignore
      service?: Input<string>;
      // Optional one or more labels that uniquely identify the service version.
      // @ts-ignore
      labels?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export interface NetworkFailPolicy {
      // @ts-ignore
      policy?: Input<FailPolicy>;
      // Max retries on transport error.
      // @ts-ignore
      maxRetry?: Input<number>;
      // Base time to wait between retries. Will be adjusted by exponential backoff and jitter.
      // @ts-ignore
      baseRetryWait?: Input<string>;
      // Max time to wait between retries.
      // @ts-ignore
      maxRetryWait?: Input<string>;
    }
    // @ts-ignore
    export type FailPolicy = Input<'FAIL_OPEN' | 'FAIL_CLOSE'>;
    // @ts-ignore
    export interface ServiceConfig {
      // If true, do not call Mixer Check.
      // @ts-ignore
      disableCheckCalls?: Input<boolean>;
      // If true, do not call Mixer Report.
      // @ts-ignore
      disableReportCalls?: Input<boolean>;
      // @ts-ignore
      mixerAttributes?: Input<Attributes>;
      // HTTP API specifications to generate API attributes.
      // @ts-ignore
      httpApiSpec?: Input<Input<HTTPAPISpec>[]>;
      // Quota specifications to generate quota requirements.
      // @ts-ignore
      quotaSpec?: Input<Input<QuotaSpec>[]>;
      // @ts-ignore
      networkFailPolicy?: Input<NetworkFailPolicy>;
      // @ts-ignore
      forwardAttributes?: Input<Attributes>;
    }
    // @ts-ignore
    export interface QuotaSpec {
      // A list of Quota rules.
      // @ts-ignore
      rules?: Input<Input<QuotaRule>[]>;
    }
    // @ts-ignore
    export interface TransportConfig {
      // @ts-ignore
      networkFailPolicy?: Input<NetworkFailPolicy>;
      // The flag to disable check cache.
      // @ts-ignore
      disableCheckCache?: Input<boolean>;
      // The flag to disable quota cache.
      // @ts-ignore
      disableQuotaCache?: Input<boolean>;
      // The flag to disable report batch.
      // @ts-ignore
      disableReportBatch?: Input<boolean>;
      // Specify refresh interval to write Mixer client statistics to Envoy share memory. If not specified, the interval is 10 seconds.
      // @ts-ignore
      statsUpdateInterval?: Input<string>;
      // Name of the cluster that will forward check calls to a pool of mixer servers. Defaults to "mixer_server". By using different names for checkCluster and reportCluster, it is possible to have one set of Mixer servers handle check calls, while another set of Mixer servers handle report calls.
      // @ts-ignore
      checkCluster?: Input<string>;
      // Name of the cluster that will forward report calls to a pool of mixer servers. Defaults to "mixer_server". By using different names for checkCluster and reportCluster, it is possible to have one set of Mixer servers handle check calls, while another set of Mixer servers handle report calls.
      // @ts-ignore
      reportCluster?: Input<string>;
      // @ts-ignore
      attributesForMixerProxy?: Input<Attributes>;
      // When disable_report_batch is false, this value specifies the maximum number of requests that are batched in report. If left unspecified, the default value of report_batch_max_entries == 0 will use the hardcoded defaults of istio::mixerclient::ReportOptions.
      // @ts-ignore
      reportBatchMaxEntries?: Input<number>;
      // When disable_report_batch is false, this value specifies the maximum elapsed time a batched report will be sent after a user request is processed. If left unspecified, the default report_batch_max_time == 0 will use the hardcoded defaults of istio::mixerclient::ReportOptions.
      // @ts-ignore
      reportBatchMaxTime?: Input<string>;
    }
    // @ts-ignore
    export interface HttpClientConfig {
      // @ts-ignore
      mixerAttributes?: Input<Attributes>;
      // @ts-ignore
      forwardAttributes?: Input<Attributes>;
      // @ts-ignore
      transport?: Input<TransportConfig>;
      // Map of control configuration indexed by destination.service. This is used to support per-service configuration for cases where a mixerclient serves multiple services.
      // @ts-ignore
      serviceConfigs?: Input<Record<Input<string>, Input<ServiceConfig>>>;
      // Default destination service name if none was specified in the client request.
      // @ts-ignore
      defaultDestinationService?: Input<string>;
      // Whether or not to use attributes forwarded in the request headers to create the attribute bag to send to mixer. For intra-mesh traffic, this should be set to "false". For ingress/egress gateways, this should be set to "true".
      // @ts-ignore
      ignoreForwardedAttributes?: Input<boolean>;
    }
    // @ts-ignore
    export interface TcpClientConfig {
      // If set to true, disables Mixer check calls.
      // @ts-ignore
      disableCheckCalls?: Input<boolean>;
      // If set to true, disables Mixer check calls.
      // @ts-ignore
      disableReportCalls?: Input<boolean>;
      // @ts-ignore
      mixerAttributes?: Input<Attributes>;
      // @ts-ignore
      transport?: Input<TransportConfig>;
      // @ts-ignore
      connectionQuotaSpec?: Input<QuotaSpec>;
      // Specify report interval to send periodical reports for long TCP connections. If not specified, the interval is 10 seconds. This interval should not be less than 1 second, otherwise it will be reset to 1 second.
      // @ts-ignore
      reportInterval?: Input<string>;
    }
    // @ts-ignore
    export interface QuotaRule {
      // The list of quotas to charge.
      // @ts-ignore
      quotas?: Input<Input<Quota>[]>;
      // If empty, match all request. If any of match is true, it is matched.
      // @ts-ignore
      match?: Input<Input<AttributeMatch>[]>;
    }
    // @ts-ignore
    export interface AttributeMatch {
      // Map of attribute names to StringMatch type. Each map element specifies one condition to match.
      // @ts-ignore
      clause?: Input<Record<Input<string>, Input<StringMatch>>>;
    }
    // @ts-ignore
    export interface Quota {
      // The quota name to charge
      // @ts-ignore
      quota?: Input<string>;
      // The quota amount to charge
      // @ts-ignore
      charge?: Input<number>;
    }
    // @ts-ignore
    export interface StringMatch {}
    // @ts-ignore
    export interface QuotaSpecBinding {
      // One or more services to map the listed QuotaSpec onto.
      // @ts-ignore
      services?: Input<Input<IstioService>[]>;
      // One or more QuotaSpec references that should be mapped to the specified service(s). The aggregate collection of match conditions defined in the QuotaSpecs should not overlap.
      // @ts-ignore
      quotaSpecs?: Input<Input<QuotaSpecReference>[]>;
    }
    // @ts-ignore
    export interface QuotaSpecReference {
      // The short name of the QuotaSpec. This is the resource name defined by the metadata name field.
      // @ts-ignore
      name?: Input<string>;
      // Optional namespace of the QuotaSpec. Defaults to the value of the metadata namespace field.
      // @ts-ignore
      namespace?: Input<string>;
    }
    // @ts-ignore
    export interface Attributes {
      // A map of attribute name to its value.
      // @ts-ignore
      attributes?: Input<Record<Input<string>, Input<AttributeValue>>>;
    }
    // @ts-ignore
    export interface AttributeValue {}
    // @ts-ignore
    export interface StringMap {
      // Holds a set of name/value pairs.
      // @ts-ignore
      entries?: Input<Record<Input<string>, Input<string>>>;
    }
  }
}

export namespace networking {
  export namespace v1alpha3 {
    export interface DestinationRuleArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<DestinationRule>;
    }
    // @ts-ignore
    export interface DestinationRule {
      // The name of a service from the service registry. Service names are looked up from the platform's service registry (e.g., Kubernetes services, Consul services, etc.) and from the hosts declared by [ServiceEntries](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry). Rules defined for services that do not exist in the service registry will be ignored.
      // @ts-ignore
      host?: Input<string>;
      // @ts-ignore
      trafficPolicy?: Input<TrafficPolicy>;
      // One or more named sets that represent individual versions of a service. Traffic policies can be overridden at subset level.
      // @ts-ignore
      subsets?: Input<Input<Subset>[]>;
      // A list of namespaces to which this destination rule is exported. The resolution of a destination rule to apply to a service occurs in the context of a hierarchy of namespaces. Exporting a destination rule allows it to be included in the resolution hierarchy for services in other namespaces. This feature provides a mechanism for service owners and mesh administrators to control the visibility of destination rules across namespace boundaries.
      // @ts-ignore
      exportTo?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export interface TrafficPolicy {
      // @ts-ignore
      loadBalancer?: Input<LoadBalancerSettings>;
      // @ts-ignore
      connectionPool?: Input<ConnectionPoolSettings>;
      // @ts-ignore
      outlierDetection?: Input<OutlierDetection>;
      // @ts-ignore
      tls?: Input<ClientTLSSettings>;
      // Traffic policies specific to individual ports. Note that port level settings will override the destination-level settings. Traffic settings specified at the destination-level will not be inherited when overridden by port-level settings, i.e. default values will be applied to fields omitted in port-level traffic policies.
      // @ts-ignore
      portLevelSettings?: Input<Input<PortTrafficPolicy>[]>;
    }
    // @ts-ignore
    export interface Subset {
      // Name of the subset. The service name and the subset name can be used for traffic splitting in a route rule.
      // @ts-ignore
      name?: Input<string>;
      // @ts-ignore
      trafficPolicy?: Input<TrafficPolicy>;
      // Labels apply a filter over the endpoints of a service in the service registry. See route rules for examples of usage.
      // @ts-ignore
      labels?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export interface LoadBalancerSettings {
      // @ts-ignore
      localityLbSetting?: Input<LocalityLoadBalancerSetting>;
    }
    // @ts-ignore
    export interface ConnectionPoolSettings {
      // @ts-ignore
      tcp?: Input<TCPSettings>;
      // @ts-ignore
      http?: Input<HTTPSettings>;
    }
    // @ts-ignore
    export interface OutlierDetection {
      // Time interval between ejection sweep analysis. format: 1h/1m/1s/1ms. MUST BE >=1ms. Default is 10s.
      // @ts-ignore
      interval?: Input<string>;
      // Number of errors before a host is ejected from the connection pool. Defaults to 5. When the upstream host is accessed over HTTP, a 502, 503, or 504 return code qualifies as an error. When the upstream host is accessed over an opaque TCP connection, connect timeouts and connection error/failure events qualify as an error. $hide_from_docs
      // @ts-ignore
      consecutiveErrors?: Input<number>;
      // Number of gateway errors before a host is ejected from the connection pool. When the upstream host is accessed over HTTP, a 502, 503, or 504 return code qualifies as a gateway error. When the upstream host is accessed over an opaque TCP connection, connect timeouts and connection error/failure events qualify as a gateway error. This feature is disabled by default or when set to the value 0.
      // @ts-ignore
      consecutiveGatewayErrors?: Input<number>;
      // Number of 5xx errors before a host is ejected from the connection pool. When the upstream host is accessed over an opaque TCP connection, connect timeouts, connection error/failure and request failure events qualify as a 5xx error. This feature defaults to 5 but can be disabled by setting the value to 0.
      // @ts-ignore
      consecutive5xxErrors?: Input<number>;
      // Minimum ejection duration. A host will remain ejected for a period equal to the product of minimum ejection duration and the number of times the host has been ejected. This technique allows the system to automatically increase the ejection period for unhealthy upstream servers. format: 1h/1m/1s/1ms. MUST BE >=1ms. Default is 30s.
      // @ts-ignore
      baseEjectionTime?: Input<string>;
      // Maximum % of hosts in the load balancing pool for the upstream service that can be ejected. Defaults to 10%.
      // @ts-ignore
      maxEjectionPercent?: Input<number>;
      // Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode. When the percentage of healthy hosts in the load balancing pool drops below this threshold, outlier detection will be disabled and the proxy will load balance across all hosts in the pool (healthy and unhealthy). The threshold can be disabled by setting it to 0%. The default is 0% as it's not typically applicable in k8s environments with few pods per service.
      // @ts-ignore
      minHealthPercent?: Input<number>;
    }
    // @ts-ignore
    export interface ClientTLSSettings {
      // @ts-ignore
      mode?: Input<TLSmode>;
      // REQUIRED if mode is `MUTUAL`. The path to the file holding the client-side TLS certificate to use. Should be empty if mode is `ISTIO_MUTUAL`.
      // @ts-ignore
      clientCertificate: Input<string>;
      // REQUIRED if mode is `MUTUAL`. The path to the file holding the client's private key. Should be empty if mode is `ISTIO_MUTUAL`.
      // @ts-ignore
      privateKey: Input<string>;
      // OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate. If omitted, the proxy will not verify the server's certificate. Should be empty if mode is `ISTIO_MUTUAL`.
      // @ts-ignore
      caCertificates?: Input<string>;
      // A list of alternate names to verify the subject identity in the certificate. If specified, the proxy will verify that the server certificate's subject alt name matches one of the specified values. If specified, this list overrides the value of subject_alt_names from the ServiceEntry.
      // @ts-ignore
      subjectAltNames?: Input<Input<string>[]>;
      // SNI string to present to the server during TLS handshake.
      // @ts-ignore
      sni?: Input<string>;
    }
    // @ts-ignore
    export interface PortTrafficPolicy {
      // @ts-ignore
      loadBalancer?: Input<LoadBalancerSettings>;
      // @ts-ignore
      connectionPool?: Input<ConnectionPoolSettings>;
      // @ts-ignore
      outlierDetection?: Input<OutlierDetection>;
      // @ts-ignore
      tls?: Input<ClientTLSSettings>;
      // @ts-ignore
      port?: Input<PortSelector>;
    }
    // @ts-ignore
    export interface PortSelector {
      // Valid port number
      // @ts-ignore
      number?: Input<number>;
    }
    // @ts-ignore
    export interface LocalityLoadBalancerSetting {
      // Optional: only one of distribute or failover can be set. Explicitly specify loadbalancing weight across different zones and geographical locations. Refer to [Locality weighted load balancing](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/locality_weight) If empty, the locality weight is set according to the endpoints number within it.
      // @ts-ignore
      distribute?: Input<Input<Distribute>[]>;
      // Optional: only failover or distribute can be set. Explicitly specify the region traffic will land on when endpoints in local region becomes unhealthy. Should be used together with OutlierDetection to detect unhealthy endpoints. Note: if no OutlierDetection specified, this will not take effect.
      // @ts-ignore
      failover?: Input<Input<Failover>[]>;
      // enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety. e.g. true means that turn on locality load balancing for this DestinationRule no matter what mesh wide settings is.
      // @ts-ignore
      enabled?: Input<boolean>;
    }
    // @ts-ignore
    export type SimpleLB = Input<'ROUND_ROBIN' | 'LEAST_CONN' | 'RANDOM' | 'PASSTHROUGH'>;
    // @ts-ignore
    export interface ConsistentHashLB {
      // The minimum number of virtual nodes to use for the hash ring. Defaults to 1024. Larger ring sizes result in more granular load distributions. If the number of hosts in the load balancing pool is larger than the ring size, each host will be assigned a single virtual node.
      // @ts-ignore
      minimumRingSize?: Input<number>;
    }
    // @ts-ignore
    export interface HTTPCookie {
      // Path to set for the cookie.
      // @ts-ignore
      path?: Input<string>;
      // Name of the cookie.
      // @ts-ignore
      name?: Input<string>;
      // Lifetime of the cookie.
      // @ts-ignore
      ttl?: Input<string>;
    }
    // @ts-ignore
    export interface TCPSettings {
      // Maximum number of HTTP1 /TCP connections to a destination host. Default 2^32-1.
      // @ts-ignore
      maxConnections?: Input<number>;
      // TCP connection timeout. format: 1h/1m/1s/1ms. MUST BE >=1ms. Default is 10s.
      // @ts-ignore
      connectTimeout?: Input<string>;
      // @ts-ignore
      tcpKeepalive?: Input<TcpKeepalive>;
    }
    // @ts-ignore
    export interface HTTPSettings {
      // Maximum number of pending HTTP requests to a destination. Default 2^32-1.
      // @ts-ignore
      http1MaxPendingRequests?: Input<number>;
      // Maximum number of requests to a backend. Default 2^32-1.
      // @ts-ignore
      http2MaxRequests?: Input<number>;
      // Maximum number of requests per connection to a backend. Setting this parameter to 1 disables keep alive. Default 0, meaning "unlimited", up to 2^29.
      // @ts-ignore
      maxRequestsPerConnection?: Input<number>;
      // Maximum number of retries that can be outstanding to all hosts in a cluster at a given time. Defaults to 2^32-1.
      // @ts-ignore
      maxRetries?: Input<number>;
      // The idle timeout for upstream connection pool connections. The idle timeout is defined as the period in which there are no active requests. If not set, the default is 1 hour. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. Applies to both HTTP1.1 and HTTP2 connections.
      // @ts-ignore
      idleTimeout?: Input<string>;
      // @ts-ignore
      h2UpgradePolicy?: Input<H2UpgradePolicy>;
    }
    // @ts-ignore
    export interface TcpKeepalive {
      // The time duration a connection needs to be idle before keep-alive probes start being sent. Default is to use the OS level configuration (unless overridden, Linux defaults to 7200s (ie 2 hours.)
      // @ts-ignore
      time?: Input<string>;
      // Maximum number of keepalive probes to send without response before deciding the connection is dead. Default is to use the OS level configuration (unless overridden, Linux defaults to 9.)
      // @ts-ignore
      probes?: Input<number>;
      // The time duration between keep-alive probes. Default is to use the OS level configuration (unless overridden, Linux defaults to 75s.)
      // @ts-ignore
      interval?: Input<string>;
    }
    // @ts-ignore
    export type H2UpgradePolicy = Input<'DEFAULT' | 'DO_NOT_UPGRADE' | 'UPGRADE'>;
    // @ts-ignore
    export type TLSmode = Input<'DISABLE' | 'SIMPLE' | 'MUTUAL' | 'ISTIO_MUTUAL'>;
    // @ts-ignore
    export interface Distribute {
      // Originating locality, '/' separated, e.g. 'region/zone/sub_zone'.
      // @ts-ignore
      from?: Input<string>;
      // Map of upstream localities to traffic distribution weights. The sum of all weights should be == 100. Any locality not assigned a weight will receive no traffic.
      // @ts-ignore
      to?: Input<Record<Input<string>, Input<number>>>;
    }
    // @ts-ignore
    export interface Failover {
      // Originating region.
      // @ts-ignore
      from?: Input<string>;
      // Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
      // @ts-ignore
      to?: Input<string>;
    }
    export interface EnvoyFilterArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<EnvoyFilter>;
    }
    // @ts-ignore
    export interface EnvoyFilter {
      // @ts-ignore
      workloadSelector?: Input<WorkloadSelector>;
      // One or more patches with match conditions.
      // @ts-ignore
      configPatches?: Input<Input<EnvoyConfigObjectPatch>[]>;
    }
    // @ts-ignore
    export interface WorkloadSelector {
      // One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied. The scope of label search is restricted to the configuration namespace in which the the resource is present.
      // @ts-ignore
      labels?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export interface EnvoyConfigObjectPatch {
      // @ts-ignore
      applyTo?: Input<ApplyTo>;
      // @ts-ignore
      match?: Input<EnvoyConfigObjectMatch>;
      // @ts-ignore
      patch?: Input<Patch>;
    }
    // @ts-ignore
    export type ApplyTo = Input<
      | 'INVALID'
      | 'LISTENER'
      | 'FILTER_CHAIN'
      | 'NETWORK_FILTER'
      | 'HTTP_FILTER'
      | 'ROUTE_CONFIGURATION'
      | 'VIRTUAL_HOST'
      | 'HTTP_ROUTE'
      | 'CLUSTER'
    >;
    // @ts-ignore
    export type PatchContext = Input<'ANY' | 'SIDECAR_INBOUND' | 'SIDECAR_OUTBOUND' | 'GATEWAY'>;
    // @ts-ignore
    export interface ProxyMatch {
      // A regular expression in golang regex format (RE2) that can be used to select proxies using a specific version of istio proxy. The Istio version for a given proxy is obtained from the node metadata field ISTIO_VERSION supplied by the proxy when connecting to Pilot. This value is embedded as an environment variable (ISTIO_META_ISTIO_VERSION) in the Istio proxy docker image. Custom proxy implementations should provide this metadata variable to take advantage of the Istio version check option.
      // @ts-ignore
      proxyVersion?: Input<string>;
      // Match on the node metadata supplied by a proxy when connecting to Istio Pilot. Note that while Envoy's node metadata is of type Struct, only string key-value pairs are processed by Pilot. All keys specified in the metadata must match with exact values. The match will fail if any of the specified keys are absent or the values fail to match.
      // @ts-ignore
      metadata?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export interface ClusterMatch {
      // The exact name of the cluster to match. To match a specific cluster by name, such as the internally generated "Passthrough" cluster, leave all fields in clusterMatch empty, except the name.
      // @ts-ignore
      name?: Input<string>;
      // The service port for which this cluster was generated. If omitted, applies to clusters for any port.
      // @ts-ignore
      portNumber?: Input<number>;
      // The fully qualified service name for this cluster. If omitted, applies to clusters for any service. For services defined through service entries, the service name is same as the hosts defined in the service entry.
      // @ts-ignore
      service?: Input<string>;
      // The subset associated with the service. If omitted, applies to clusters for any subset of a service.
      // @ts-ignore
      subset?: Input<string>;
    }
    // @ts-ignore
    export interface RouteConfigurationMatch {
      // Route configuration name to match on. Can be used to match a specific route configuration by name, such as the internally generated "http_proxy" route configuration for all sidecars.
      // @ts-ignore
      name?: Input<string>;
      // The service port number or gateway server port number for which this route configuration was generated. If omitted, applies to route configurations for all ports.
      // @ts-ignore
      portNumber?: Input<number>;
      // Applicable only for GATEWAY context. The gateway server port name for which this route configuration was generated.
      // @ts-ignore
      portName?: Input<string>;
      // The Istio gateway config's namespace/name for which this route configuration was generated. Applies only if the context is GATEWAY. Should be in the namespace/name format. Use this field in conjunction with the portNumber and portName to accurately select the Envoy route configuration for a specific HTTPS server within a gateway config object.
      // @ts-ignore
      gateway?: Input<string>;
      // @ts-ignore
      vhost?: Input<VirtualHostMatch>;
    }
    // @ts-ignore
    export interface VirtualHostMatch {
      // The VirtualHosts objects generated by Istio are named as host:port, where the host typically corresponds to the VirtualService's host field or the hostname of a service in the registry.
      // @ts-ignore
      name?: Input<string>;
      // @ts-ignore
      route?: Input<RouteMatch>;
    }
    // @ts-ignore
    export interface RouteMatch {
      // The Route objects generated by default are named as "default". Route objects generated using a virtual service will carry the name used in the virtual service's HTTP routes.
      // @ts-ignore
      name?: Input<string>;
      // @ts-ignore
      action?: Input<Action>;
    }
    // @ts-ignore
    export type Action = Input<'ANY' | 'ROUTE' | 'REDIRECT' | 'DIRECT_RESPONSE'>;
    // @ts-ignore
    export interface ListenerMatch {
      // Match a specific listener by its name. The listeners generated by Pilot are typically named as IP:Port.
      // @ts-ignore
      name?: Input<string>;
      // The service port/gateway port to which traffic is being sent/received. If not specified, matches all listeners. Even though inbound listeners are generated for the instance/pod ports, only service ports should be used to match listeners.
      // @ts-ignore
      portNumber?: Input<number>;
      // Instead of using specific port numbers, a set of ports matching a given service's port name can be selected. Matching is case insensitive. Not implemented. $hide_from_docs
      // @ts-ignore
      portName?: Input<string>;
      // @ts-ignore
      filterChain?: Input<FilterChainMatch>;
    }
    // @ts-ignore
    export interface FilterChainMatch {
      // The name assigned to the filter chain.
      // @ts-ignore
      name?: Input<string>;
      // The SNI value used by a filter chain's match condition. This condition will evaluate to false if the filter chain has no sni match.
      // @ts-ignore
      sni?: Input<string>;
      // Applies only to SIDECAR_INBOUND context. If non-empty, a transport protocol to consider when determining a filter chain match. This value will be compared against the transport protocol of a new connection, when it's detected by the tls_inspector listener filter.
      // @ts-ignore
      transportProtocol?: Input<string>;
      // Applies only to sidecars. If non-empty, a comma separated set of application protocols to consider when determining a filter chain match. This value will be compared against the application protocols of a new connection, when it's detected by one of the listener filters such as the http_inspector.
      // @ts-ignore
      applicationProtocols?: Input<string>;
      // @ts-ignore
      filter?: Input<FilterMatch>;
    }
    // @ts-ignore
    export interface FilterMatch {
      // The filter name to match on.
      // @ts-ignore
      name?: Input<string>;
      // @ts-ignore
      subFilter?: Input<SubFilterMatch>;
    }
    // @ts-ignore
    export interface SubFilterMatch {
      // The filter name to match on.
      // @ts-ignore
      name?: Input<string>;
    }
    // @ts-ignore
    export interface Patch {
      // @ts-ignore
      operation?: Input<Operation>;
      // The JSON config of the object being patched. This will be merged using json merge semantics with the existing proto in the path.
      // @ts-ignore
      value?: Input<object>;
    }
    // @ts-ignore
    export type Operation = Input<
      'INVALID' | 'MERGE' | 'ADD' | 'REMOVE' | 'INSERT_BEFORE' | 'INSERT_AFTER' | 'INSERT_FIRST'
    >;
    // @ts-ignore
    export interface EnvoyConfigObjectMatch {
      // @ts-ignore
      context?: Input<PatchContext>;
      // @ts-ignore
      proxy?: Input<ProxyMatch>;
    }
    export interface GatewayArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<Gateway>;
    }
    // @ts-ignore
    export interface Gateway {
      // A list of server specifications.
      // @ts-ignore
      servers?: Input<Input<Server>[]>;
      // One or more labels that indicate a specific set of pods/VMs on which this gateway configuration should be applied. The scope of label search is restricted to the configuration namespace in which the the resource is present. In other words, the Gateway resource must reside in the same namespace as the gateway workload instance. If selector is nil, the Gateway will be applied to all workloads.
      // @ts-ignore
      selector?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export interface Server {
      // @ts-ignore
      tls?: Input<ServerTLSSettings>;
      // @ts-ignore
      port?: Input<Port>;
      // The ip or the Unix domain socket to which the listener should be bound to. Format: `x.x.x.x` or `unix:///path/to/uds` or `unix://@foobar` (Linux abstract namespace). When using Unix domain sockets, the port number should be 0.
      // @ts-ignore
      bind?: Input<string>;
      // One or more hosts exposed by this gateway. While typically applicable to HTTP services, it can also be used for TCP services using TLS with SNI. A host is specified as a `dnsName` with an optional `namespace/` prefix. The `dnsName` should be specified using FQDN format, optionally including a wildcard character in the left-most component (e.g., `prod/*.example.com`). Set the `dnsName` to `*` to select all `VirtualService` hosts from the specified namespace (e.g.,`prod/*`).
      // @ts-ignore
      hosts?: Input<Input<string>[]>;
      // The loopback IP endpoint or Unix domain socket to which traffic should be forwarded to by default. Format should be `127.0.0.1:PORT` or `unix:///path/to/socket` or `unix://@foobar` (Linux abstract namespace). NOT IMPLEMENTED. $hide_from_docs
      // @ts-ignore
      defaultEndpoint?: Input<string>;
    }
    // @ts-ignore
    export interface Port {
      // A valid non-negative integer port number.
      // @ts-ignore
      number?: Input<number>;
      // Label assigned to the port.
      // @ts-ignore
      name?: Input<string>;
      // The protocol exposed on the port. MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS. TLS implies the connection will be routed based on the SNI header to the destination without terminating the TLS connection.
      // @ts-ignore
      protocol?: Input<string>;
    }
    // @ts-ignore
    export interface ServerTLSSettings {
      // @ts-ignore
      mode?: Input<TLSmode>;
      // REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file holding the server's private key.
      // @ts-ignore
      privateKey: Input<string>;
      // REQUIRED if mode is `MUTUAL`. The path to a file containing certificate authority certificates to use in verifying a presented client side certificate.
      // @ts-ignore
      caCertificates: Input<string>;
      // A list of alternate names to verify the subject identity in the certificate presented by the client.
      // @ts-ignore
      subjectAltNames?: Input<Input<string>[]>;
      // If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
      // @ts-ignore
      httpsRedirect?: Input<boolean>;
      // REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file holding the server-side TLS certificate to use.
      // @ts-ignore
      serverCertificate: Input<string>;
      // For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates. Applicable only on Kubernetes, and only if the dynamic credential fetching feature is enabled in the proxy by setting `ISTIO_META_USER_SDS` metadata variable. The secret (of type `generic`) should contain the following keys and values: `key: <privateKey>`, `cert: <serverCert>`, `cacert: <CACertificate>`.
      // @ts-ignore
      credentialName?: Input<string>;
      // An optional list of base64-encoded SHA-256 hashes of the SKPIs of authorized client certificates. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.
      // @ts-ignore
      verifyCertificateSpki?: Input<Input<string>[]>;
      // An optional list of hex-encoded SHA-256 hashes of the authorized client certificates. Both simple and colon separated formats are acceptable. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.
      // @ts-ignore
      verifyCertificateHash?: Input<Input<string>[]>;
      // @ts-ignore
      minProtocolVersion?: Input<TLSProtocol>;
      // @ts-ignore
      maxProtocolVersion?: Input<TLSProtocol>;
      // Optional: If specified, only support the specified cipher list. Otherwise default to the default cipher list supported by Envoy.
      // @ts-ignore
      cipherSuites?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export type TLSmode = Input<'PASSTHROUGH' | 'SIMPLE' | 'MUTUAL' | 'AUTO_PASSTHROUGH' | 'ISTIO_MUTUAL'>;
    // @ts-ignore
    export type TLSProtocol = Input<'TLS_AUTO' | 'TLSV1_0' | 'TLSV1_1' | 'TLSV1_2' | 'TLSV1_3'>;
    // @ts-ignore
    export interface WorkloadSelector {
      // One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied. The scope of label search is restricted to the configuration namespace in which the the resource is present.
      // @ts-ignore
      labels?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export interface Port {
      // A valid non-negative integer port number.
      // @ts-ignore
      number?: Input<number>;
      // Label assigned to the port.
      // @ts-ignore
      name?: Input<string>;
      // The protocol exposed on the port. MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS. TLS implies the connection will be routed based on the SNI header to the destination without terminating the TLS connection.
      // @ts-ignore
      protocol?: Input<string>;
    }
    export interface ServiceEntryArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<ServiceEntry>;
    }
    // @ts-ignore
    export interface ServiceEntry {
      // A list of namespaces to which this service is exported. Exporting a service allows it to be used by sidecars, gateways and virtual services defined in other namespaces. This feature provides a mechanism for service owners and mesh administrators to control the visibility of services across namespace boundaries.
      // @ts-ignore
      exportTo?: Input<Input<string>[]>;
      // If specified, the proxy will verify that the server certificate's subject alternate name matches one of the specified values.
      // @ts-ignore
      subjectAltNames?: Input<Input<string>[]>;
      // @ts-ignore
      workloadSelector?: Input<WorkloadSelector>;
      // The hosts associated with the ServiceEntry. Could be a DNS name with wildcard prefix.
      // @ts-ignore
      hosts?: Input<Input<string>[]>;
      // The virtual IP addresses associated with the service. Could be CIDR prefix. For HTTP traffic, generated route configurations will include http route domains for both the `addresses` and `hosts` field values and the destination will be identified based on the HTTP Host/Authority header. If one or more IP addresses are specified, the incoming traffic will be identified as belonging to this service if the destination IP matches the IP/CIDRs specified in the addresses field. If the Addresses field is empty, traffic will be identified solely based on the destination port. In such scenarios, the port on which the service is being accessed must not be shared by any other service in the mesh. In other words, the sidecar will behave as a simple TCP proxy, forwarding incoming traffic on a specified port to the specified destination endpoint IP/host. Unix domain socket addresses are not supported in this field.
      // @ts-ignore
      addresses?: Input<Input<string>[]>;
      // The ports associated with the external service. If the Endpoints are Unix domain socket addresses, there must be exactly one port.
      // @ts-ignore
      ports?: Input<Input<Port>[]>;
      // @ts-ignore
      location?: Input<Location>;
      // @ts-ignore
      resolution?: Input<Resolution>;
      // One or more endpoints associated with the service. Only one of `endpoints` or `workloadSelector` can be specified.
      // @ts-ignore
      endpoints?: Input<Input<WorkloadEntry>[]>;
    }
    // @ts-ignore
    export type Location = Input<'MESH_EXTERNAL' | 'MESH_INTERNAL'>;
    // @ts-ignore
    export type Resolution = Input<'NONE' | 'STATIC' | 'DNS'>;
    // @ts-ignore
    export interface WorkloadEntry {
      // One or more labels associated with the endpoint.
      // @ts-ignore
      labels?: Input<Record<Input<string>, Input<string>>>;
      // Set of ports associated with the endpoint. The ports must be associated with a port name that was declared as part of the service. Do not use for `unix://` addresses.
      // @ts-ignore
      ports?: Input<Record<Input<string>, Input<number>>>;
      // The load balancing weight associated with the endpoint. Endpoints with higher weights will receive proportionally higher traffic.
      // @ts-ignore
      weight?: Input<number>;
      // Address associated with the network endpoint without the port. Domain names can be used if and only if the resolution is set to DNS, and must be fully-qualified without wildcards. Use the form unix:///absolute/path/to/socket for Unix domain socket endpoints.
      // @ts-ignore
      address?: Input<string>;
      // Network enables Istio to group endpoints resident in the same L3 domain/network. All endpoints in the same network are assumed to be directly reachable from one another. When endpoints in different networks cannot reach each other directly, an Istio Gateway can be used to establish connectivity (usually using the `AUTO_PASSTHROUGH` mode in a Gateway Server). This is an advanced configuration used typically for spanning an Istio mesh over multiple clusters.
      // @ts-ignore
      network?: Input<string>;
      // The locality associated with the endpoint. A locality corresponds to a failure domain (e.g., country/region/zone). Arbitrary failure domain hierarchies can be represented by separating each encapsulating failure domain by /. For example, the locality of an an endpoint in US, in US-East-1 region, within availability zone az-1, in data center rack r11 can be represented as us/us-east-1/az-1/r11. Istio will configure the sidecar to route to endpoints within the same locality as the sidecar. If none of the endpoints in the locality are available, endpoints parent locality (but within the same network ID) will be chosen. For example, if there are two endpoints in same network (networkID "n1"), say e1 with locality us/us-east-1/az-1/r11 and e2 with locality us/us-east-1/az-2/r12, a sidecar from us/us-east-1/az-1/r11 locality will prefer e1 from the same locality over e2 from a different locality. Endpoint e2 could be the IP associated with a gateway (that bridges networks n1 and n2), or the IP associated with a standard service endpoint.
      // @ts-ignore
      locality?: Input<string>;
      // The service account associated with the workload if a sidecar is present in the workload. The service account must be present in the same namespace as the configuration ( WorkloadEntry or a ServiceEntry)
      // @ts-ignore
      serviceAccount?: Input<string>;
    }
    // @ts-ignore
    export interface ClientTLSSettings {
      // @ts-ignore
      mode?: Input<TLSmode>;
      // REQUIRED if mode is `MUTUAL`. The path to the file holding the client-side TLS certificate to use. Should be empty if mode is `ISTIO_MUTUAL`.
      // @ts-ignore
      clientCertificate: Input<string>;
      // REQUIRED if mode is `MUTUAL`. The path to the file holding the client's private key. Should be empty if mode is `ISTIO_MUTUAL`.
      // @ts-ignore
      privateKey: Input<string>;
      // OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate. If omitted, the proxy will not verify the server's certificate. Should be empty if mode is `ISTIO_MUTUAL`.
      // @ts-ignore
      caCertificates?: Input<string>;
      // A list of alternate names to verify the subject identity in the certificate. If specified, the proxy will verify that the server certificate's subject alt name matches one of the specified values. If specified, this list overrides the value of subject_alt_names from the ServiceEntry.
      // @ts-ignore
      subjectAltNames?: Input<Input<string>[]>;
      // SNI string to present to the server during TLS handshake.
      // @ts-ignore
      sni?: Input<string>;
    }
    // @ts-ignore
    export interface PortSelector {
      // Valid port number
      // @ts-ignore
      number?: Input<number>;
    }
    // @ts-ignore
    export type TLSmode = Input<'DISABLE' | 'SIMPLE' | 'MUTUAL' | 'ISTIO_MUTUAL'>;
    // @ts-ignore
    export interface WorkloadSelector {
      // One or more labels that indicate a specific set of pods/VMs on which the configuration should be applied. The scope of label search is restricted to the configuration namespace in which the the resource is present.
      // @ts-ignore
      labels?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export interface Port {
      // A valid non-negative integer port number.
      // @ts-ignore
      number?: Input<number>;
      // Label assigned to the port.
      // @ts-ignore
      name?: Input<string>;
      // The protocol exposed on the port. MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS. TLS implies the connection will be routed based on the SNI header to the destination without terminating the TLS connection.
      // @ts-ignore
      protocol?: Input<string>;
    }
    // @ts-ignore
    export interface ServerTLSSettings {
      // @ts-ignore
      mode?: Input<TLSmode>;
      // REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file holding the server's private key.
      // @ts-ignore
      privateKey: Input<string>;
      // REQUIRED if mode is `MUTUAL`. The path to a file containing certificate authority certificates to use in verifying a presented client side certificate.
      // @ts-ignore
      caCertificates: Input<string>;
      // A list of alternate names to verify the subject identity in the certificate presented by the client.
      // @ts-ignore
      subjectAltNames?: Input<Input<string>[]>;
      // If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
      // @ts-ignore
      httpsRedirect?: Input<boolean>;
      // REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file holding the server-side TLS certificate to use.
      // @ts-ignore
      serverCertificate: Input<string>;
      // For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates. Applicable only on Kubernetes, and only if the dynamic credential fetching feature is enabled in the proxy by setting `ISTIO_META_USER_SDS` metadata variable. The secret (of type `generic`) should contain the following keys and values: `key: <privateKey>`, `cert: <serverCert>`, `cacert: <CACertificate>`.
      // @ts-ignore
      credentialName?: Input<string>;
      // An optional list of base64-encoded SHA-256 hashes of the SKPIs of authorized client certificates. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.
      // @ts-ignore
      verifyCertificateSpki?: Input<Input<string>[]>;
      // An optional list of hex-encoded SHA-256 hashes of the authorized client certificates. Both simple and colon separated formats are acceptable. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.
      // @ts-ignore
      verifyCertificateHash?: Input<Input<string>[]>;
      // @ts-ignore
      minProtocolVersion?: Input<TLSProtocol>;
      // @ts-ignore
      maxProtocolVersion?: Input<TLSProtocol>;
      // Optional: If specified, only support the specified cipher list. Otherwise default to the default cipher list supported by Envoy.
      // @ts-ignore
      cipherSuites?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export type TLSmode = Input<'PASSTHROUGH' | 'SIMPLE' | 'MUTUAL' | 'AUTO_PASSTHROUGH' | 'ISTIO_MUTUAL'>;
    // @ts-ignore
    export type TLSProtocol = Input<'TLS_AUTO' | 'TLSV1_0' | 'TLSV1_1' | 'TLSV1_2' | 'TLSV1_3'>;
    export interface SidecarArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<Sidecar>;
    }
    // @ts-ignore
    export interface Sidecar {
      // @ts-ignore
      workloadSelector?: Input<WorkloadSelector>;
      // Ingress specifies the configuration of the sidecar for processing inbound traffic to the attached workload instance. If omitted, Istio will automatically configure the sidecar based on the information about the workload obtained from the orchestration platform (e.g., exposed ports, services, etc.). If specified, inbound ports are configured if and only if the workload instance is associated with a service.
      // @ts-ignore
      ingress?: Input<Input<IstioIngressListener>[]>;
      // Egress specifies the configuration of the sidecar for processing outbound traffic from the attached workload instance to other services in the mesh. If not specified, inherits the system detected defaults from the namespace-wide or the global default Sidecar.
      // @ts-ignore
      egress?: Input<Input<IstioEgressListener>[]>;
      // @ts-ignore
      outboundTrafficPolicy?: Input<OutboundTrafficPolicy>;
      // @ts-ignore
      localhost?: Input<Localhost>;
    }
    // @ts-ignore
    export interface IstioIngressListener {
      // @ts-ignore
      port?: Input<Port>;
      // The IP to which the listener should be bound. Must be in the format `x.x.x.x`. Unix domain socket addresses are not allowed in the bind field for ingress listeners. If omitted, Istio will automatically configure the defaults based on imported services and the workload instances to which this configuration is applied to.
      // @ts-ignore
      bind?: Input<string>;
      // The loopback IP endpoint or Unix domain socket to which traffic should be forwarded to. This configuration can be used to redirect traffic arriving at the bind `IP:Port` on the sidecar to a `localhost:port` or Unix domain socket where the application workload instance is listening for connections. Format should be `127.0.0.1:PORT` or `unix:///path/to/socket`
      // @ts-ignore
      defaultEndpoint?: Input<string>;
      // @ts-ignore
      captureMode?: Input<CaptureMode>;
      // @ts-ignore
      localhostClientTls?: Input<ClientTLSSettings>;
    }
    // @ts-ignore
    export interface IstioEgressListener {
      // @ts-ignore
      port?: Input<Port>;
      // The IP or the Unix domain socket to which the listener should be bound to. Port MUST be specified if bind is not empty. Format: `x.x.x.x` or `unix:///path/to/uds` or `unix://@foobar` (Linux abstract namespace). If omitted, Istio will automatically configure the defaults based on imported services, the workload instances to which this configuration is applied to and the captureMode. If captureMode is `NONE`, bind will default to 127.0.0.1.
      // @ts-ignore
      bind?: Input<string>;
      // One or more service hosts exposed by the listener in `namespace/dnsName` format. Services in the specified namespace matching `dnsName` will be exposed. The corresponding service can be a service in the service registry (e.g., a Kubernetes or cloud foundry service) or a service specified using a `ServiceEntry` or `VirtualService` configuration. Any associated `DestinationRule` in the same namespace will also be used.
      // @ts-ignore
      hosts?: Input<Input<string>[]>;
      // @ts-ignore
      captureMode?: Input<CaptureMode>;
      // @ts-ignore
      localhostServerTls?: Input<ServerTLSSettings>;
    }
    // @ts-ignore
    export interface OutboundTrafficPolicy {
      // @ts-ignore
      mode?: Input<Mode>;
      // @ts-ignore
      egressProxy?: Input<Destination>;
    }
    // @ts-ignore
    export interface Localhost {
      // @ts-ignore
      clientTls?: Input<ClientTLSSettings>;
      // @ts-ignore
      serverTls?: Input<ServerTLSSettings>;
    }
    // @ts-ignore
    export type CaptureMode = Input<'DEFAULT' | 'IPTABLES' | 'NONE'>;
    // @ts-ignore
    export type Mode = Input<'REGISTRY_ONLY' | 'ALLOW_ANY'>;
    // @ts-ignore
    export interface Destination {
      // The name of a service from the service registry. Service names are looked up from the platform's service registry (e.g., Kubernetes services, Consul services, etc.) and from the hosts declared by [ServiceEntry](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry). Traffic forwarded to destinations that are not found in either of the two, will be dropped.
      // @ts-ignore
      host?: Input<string>;
      // @ts-ignore
      port?: Input<PortSelector>;
      // The name of a subset within the service. Applicable only to services within the mesh. The subset must be defined in a corresponding DestinationRule.
      // @ts-ignore
      subset?: Input<string>;
    }
    // @ts-ignore
    export interface PortSelector {
      // Valid port number
      // @ts-ignore
      number?: Input<number>;
    }
    // @ts-ignore
    export interface Destination {
      // The name of a service from the service registry. Service names are looked up from the platform's service registry (e.g., Kubernetes services, Consul services, etc.) and from the hosts declared by [ServiceEntry](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry). Traffic forwarded to destinations that are not found in either of the two, will be dropped.
      // @ts-ignore
      host?: Input<string>;
      // @ts-ignore
      port?: Input<PortSelector>;
      // The name of a subset within the service. Applicable only to services within the mesh. The subset must be defined in a corresponding DestinationRule.
      // @ts-ignore
      subset?: Input<string>;
    }
    export interface VirtualServiceArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<VirtualService>;
    }
    // @ts-ignore
    export interface VirtualService {
      // A list of namespaces to which this virtual service is exported. Exporting a virtual service allows it to be used by sidecars and gateways defined in other namespaces. This feature provides a mechanism for service owners and mesh administrators to control the visibility of virtual services across namespace boundaries.
      // @ts-ignore
      exportTo?: Input<Input<string>[]>;
      // An ordered list of route rule for non-terminated TLS & HTTPS traffic. Routing is typically performed using the SNI value presented by the ClientHello message. TLS routes will be applied to platform service ports named 'https-*', 'tls-*', unterminated gateway ports using HTTPS/TLS protocols (i.e. with "passthrough" TLS mode) and service entry ports using HTTPS/TLS protocols. The first rule matching an incoming request is used. NOTE: Traffic 'https-*' or 'tls-*' ports without associated virtual service will be treated as opaque TCP traffic.
      // @ts-ignore
      tls?: Input<Input<TLSRoute>[]>;
      // An ordered list of route rules for opaque TCP traffic. TCP routes will be applied to any port that is not a HTTP or TLS port. The first rule matching an incoming request is used.
      // @ts-ignore
      tcp?: Input<Input<TCPRoute>[]>;
      // An ordered list of route rules for HTTP traffic. HTTP routes will be applied to platform service ports named 'http-*'/'http2-*'/'grpc-*', gateway ports with protocol HTTP/HTTP2/GRPC/ TLS-terminated-HTTPS and service entry ports using HTTP/HTTP2/GRPC protocols. The first rule matching an incoming request is used.
      // @ts-ignore
      http?: Input<Input<HTTPRoute>[]>;
      // The destination hosts to which traffic is being sent. Could be a DNS name with wildcard prefix or an IP address. Depending on the platform, short-names can also be used instead of a FQDN (i.e. has no dots in the name). In such a scenario, the FQDN of the host would be derived based on the underlying platform.
      // @ts-ignore
      hosts?: Input<Input<string>[]>;
      // The names of gateways and sidecars that should apply these routes. Gateways in other namespaces may be referred to by `<gateway namespace>/<gateway name>`; specifying a gateway with no namespace qualifier is the same as specifying the VirtualService's namespace. A single VirtualService is used for sidecars inside the mesh as well as for one or more gateways. The selection condition imposed by this field can be overridden using the source field in the match conditions of protocol-specific routes. The reserved word `mesh` is used to imply all the sidecars in the mesh. When this field is omitted, the default gateway (`mesh`) will be used, which would apply the rule to all sidecars in the mesh. If a list of gateway names is provided, the rules will apply only to the gateways. To apply the rules to both gateways and sidecars, specify `mesh` as one of the gateway names.
      // @ts-ignore
      gateways?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export interface HTTPRoute {
      // The name assigned to the route for debugging purposes. The route's name will be concatenated with the match's name and will be logged in the access logs for requests matching this route/match.
      // @ts-ignore
      name?: Input<string>;
      // A HTTP rule can either redirect or forward (default) traffic. The forwarding target can be one of several versions of a service (see glossary in beginning of document). Weights associated with the service version determine the proportion of traffic it receives.
      // @ts-ignore
      route?: Input<Input<HTTPRouteDestination>[]>;
      // Match conditions to be satisfied for the rule to be activated. All conditions inside a single match block have AND semantics, while the list of match blocks have OR semantics. The rule is matched if any one of the match blocks succeed.
      // @ts-ignore
      match?: Input<Input<HTTPMatchRequest>[]>;
      // @ts-ignore
      redirect?: Input<HTTPRedirect>;
      // @ts-ignore
      delegate?: Input<Delegate>;
      // @ts-ignore
      rewrite?: Input<HTTPRewrite>;
      // Timeout for HTTP requests.
      // @ts-ignore
      timeout?: Input<string>;
      // @ts-ignore
      retries?: Input<HTTPRetry>;
      // @ts-ignore
      fault?: Input<HTTPFaultInjection>;
      // @ts-ignore
      mirror?: Input<Destination>;
      // Percentage of the traffic to be mirrored by the `mirror` field. Use of integer `mirror_percent` value is deprecated. Use the double `mirror_percentage` field instead
      // @ts-ignore
      mirrorPercent?: Input<number>;
      // @ts-ignore
      mirrorPercentage?: Input<Percent>;
      // @ts-ignore
      corsPolicy?: Input<CorsPolicy>;
      // @ts-ignore
      headers?: Input<Headers>;
    }
    // @ts-ignore
    export interface TLSRoute {
      // The destination to which the connection should be forwarded to.
      // @ts-ignore
      route?: Input<Input<RouteDestination>[]>;
      // Match conditions to be satisfied for the rule to be activated. All conditions inside a single match block have AND semantics, while the list of match blocks have OR semantics. The rule is matched if any one of the match blocks succeed.
      // @ts-ignore
      match?: Input<Input<TLSMatchAttributes>[]>;
    }
    // @ts-ignore
    export interface TCPRoute {
      // The destination to which the connection should be forwarded to.
      // @ts-ignore
      route?: Input<Input<RouteDestination>[]>;
      // Match conditions to be satisfied for the rule to be activated. All conditions inside a single match block have AND semantics, while the list of match blocks have OR semantics. The rule is matched if any one of the match blocks succeed.
      // @ts-ignore
      match?: Input<Input<L4MatchAttributes>[]>;
    }
    // @ts-ignore
    export interface HTTPMatchRequest {
      // The name assigned to a match. The match's name will be concatenated with the parent route's name and will be logged in the access logs for requests matching this route.
      // @ts-ignore
      name?: Input<string>;
      // @ts-ignore
      method?: Input<StringMatch>;
      // Specifies the ports on the host that is being addressed. Many services only expose a single port or label ports with the protocols they support, in these cases it is not required to explicitly select the port.
      // @ts-ignore
      port?: Input<number>;
      // Names of gateways where the rule should be applied. Gateway names in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway match is independent of sourceLabels.
      // @ts-ignore
      gateways?: Input<Input<string>[]>;
      // The header keys must be lowercase and use hyphen as the separator, e.g. _x-request-id_.
      // @ts-ignore
      headers?: Input<Record<Input<string>, Input<StringMatch>>>;
      // @ts-ignore
      uri?: Input<StringMatch>;
      // @ts-ignore
      scheme?: Input<StringMatch>;
      // @ts-ignore
      authority?: Input<StringMatch>;
      // One or more labels that constrain the applicability of a rule to workloads with the given labels. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it must include the reserved gateway `mesh` for this field to be applicable.
      // @ts-ignore
      sourceLabels?: Input<Record<Input<string>, Input<string>>>;
      // Query parameters for matching.
      // @ts-ignore
      queryParams?: Input<Record<Input<string>, Input<StringMatch>>>;
      // Flag to specify whether the URI matching should be case-insensitive.
      // @ts-ignore
      ignoreUriCase?: Input<boolean>;
      // withoutHeader has the same syntax with the header, but has opposite meaning. If a header is matched with a matching rule among withoutHeader, the traffic becomes not matched one.
      // @ts-ignore
      withoutHeaders?: Input<Record<Input<string>, Input<StringMatch>>>;
      // Source namespace constraining the applicability of a rule to workloads in that namespace. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it must include the reserved gateway `mesh` for this field to be applicable.
      // @ts-ignore
      sourceNamespace?: Input<string>;
    }
    // @ts-ignore
    export interface HTTPRouteDestination {
      // @ts-ignore
      headers?: Input<Headers>;
      // @ts-ignore
      destination?: Input<Destination>;
      // The proportion of traffic to be forwarded to the service version. (0-100). Sum of weights across destinations SHOULD BE == 100. If there is only one destination in a rule, the weight value is assumed to be 100.
      // @ts-ignore
      weight?: Input<number>;
    }
    // @ts-ignore
    export interface HTTPRedirect {
      // On a redirect, overwrite the Path portion of the URL with this value. Note that the entire path will be replaced, irrespective of the request URI being matched as an exact path or prefix.
      // @ts-ignore
      uri?: Input<string>;
      // On a redirect, overwrite the Authority/Host portion of the URL with this value.
      // @ts-ignore
      authority?: Input<string>;
      // On a redirect, Specifies the HTTP status code to use in the redirect response. The default response code is MOVED_PERMANENTLY (301).
      // @ts-ignore
      redirectCode?: Input<number>;
    }
    // @ts-ignore
    export interface Delegate {
      // Name specifies the name of the delegate VirtualService.
      // @ts-ignore
      name?: Input<string>;
      // Namespace specifies the namespace where the delegate VirtualService resides. By default, it is same to the root's.
      // @ts-ignore
      namespace?: Input<string>;
    }
    // @ts-ignore
    export interface HTTPRewrite {
      // rewrite the path (or the prefix) portion of the URI with this value. If the original URI was matched based on prefix, the value provided in this field will replace the corresponding matched prefix.
      // @ts-ignore
      uri?: Input<string>;
      // rewrite the Authority/Host header with this value.
      // @ts-ignore
      authority?: Input<string>;
    }
    // @ts-ignore
    export interface HTTPRetry {
      // Number of retries for a given request. The interval between retries will be determined automatically (25ms+). Actual number of retries attempted depends on the request `timeout` of the [HTTP route](https://istio.io/docs/reference/config/networking/virtual-service/#HTTPRoute).
      // @ts-ignore
      attempts?: Input<number>;
      // Timeout per retry attempt for a given request. format: 1h/1m/1s/1ms. MUST BE >=1ms.
      // @ts-ignore
      perTryTimeout?: Input<string>;
      // Specifies the conditions under which retry takes place. One or more policies can be specified using a , delimited list. See the [retry policies](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on) and [gRPC retry policies](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on) for more details.
      // @ts-ignore
      retryOn?: Input<string>;
      // Flag to specify whether the retries should retry to other localities. See the [retry plugin configuration](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/http_connection_management#retry-plugin-configuration) for more details.
      // @ts-ignore
      retryRemoteLocalities?: Input<boolean>;
    }
    // @ts-ignore
    export interface HTTPFaultInjection {
      // @ts-ignore
      delay?: Input<Delay>;
      // @ts-ignore
      abort?: Input<Abort>;
    }
    // @ts-ignore
    export interface Percent {
      // @ts-ignore
      value?: Input<number>;
    }
    // @ts-ignore
    export interface CorsPolicy {
      // The list of origins that are allowed to perform CORS requests. The content will be serialized into the Access-Control-Allow-Origin header. Wildcard * will allow all origins. $hide_from_docs
      // @ts-ignore
      allowOrigin?: Input<Input<string>[]>;
      // String patterns that match allowed origins. An origin is allowed if any of the string matchers match. If a match is found, then the outgoing Access-Control-Allow-Origin would be set to the origin as provided by the client.
      // @ts-ignore
      allowOrigins?: Input<Input<StringMatch>[]>;
      // List of HTTP methods allowed to access the resource. The content will be serialized into the Access-Control-Allow-Methods header.
      // @ts-ignore
      allowMethods?: Input<Input<string>[]>;
      // List of HTTP headers that can be used when requesting the resource. Serialized to Access-Control-Allow-Headers header.
      // @ts-ignore
      allowHeaders?: Input<Input<string>[]>;
      // A white list of HTTP headers that the browsers are allowed to access. Serialized into Access-Control-Expose-Headers header.
      // @ts-ignore
      exposeHeaders?: Input<Input<string>[]>;
      // Specifies how long the results of a preflight request can be cached. Translates to the `Access-Control-Max-Age` header.
      // @ts-ignore
      maxAge?: Input<string>;
      // Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials. Translates to `Access-Control-Allow-Credentials` header.
      // @ts-ignore
      allowCredentials?: Input<boolean>;
    }
    // @ts-ignore
    export interface Headers {
      // @ts-ignore
      response?: Input<HeaderOperations>;
      // @ts-ignore
      request?: Input<HeaderOperations>;
    }
    // @ts-ignore
    export interface HeaderOperations {
      // Overwrite the headers specified by key with the given values
      // @ts-ignore
      set?: Input<Record<Input<string>, Input<string>>>;
      // Append the given values to the headers specified by keys (will create a comma-separated list of values)
      // @ts-ignore
      add?: Input<Record<Input<string>, Input<string>>>;
      // Remove a the specified headers
      // @ts-ignore
      remove?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export interface TLSMatchAttributes {
      // Specifies the port on the host that is being addressed. Many services only expose a single port or label ports with the protocols they support, in these cases it is not required to explicitly select the port.
      // @ts-ignore
      port?: Input<number>;
      // Names of gateways where the rule should be applied. Gateway names in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway match is independent of sourceLabels.
      // @ts-ignore
      gateways?: Input<Input<string>[]>;
      // One or more labels that constrain the applicability of a rule to workloads with the given labels. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it should include the reserved gateway `mesh` in order for this field to be applicable.
      // @ts-ignore
      sourceLabels?: Input<Record<Input<string>, Input<string>>>;
      // Source namespace constraining the applicability of a rule to workloads in that namespace. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it must include the reserved gateway `mesh` for this field to be applicable.
      // @ts-ignore
      sourceNamespace?: Input<string>;
      // IPv4 or IPv6 ip addresses of destination with optional subnet. E.g., a.b.c.d/xx form or just a.b.c.d.
      // @ts-ignore
      destinationSubnets?: Input<Input<string>[]>;
      // SNI (server name indicator) to match on. Wildcard prefixes can be used in the SNI value, e.g., *.com will match foo.example.com as well as example.com. An SNI value must be a subset (i.e., fall within the domain) of the corresponding virtual serivce's hosts.
      // @ts-ignore
      sniHosts?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export interface RouteDestination {
      // @ts-ignore
      destination?: Input<Destination>;
      // The proportion of traffic to be forwarded to the service version. If there is only one destination in a rule, all traffic will be routed to it irrespective of the weight.
      // @ts-ignore
      weight?: Input<number>;
    }
    // @ts-ignore
    export interface L4MatchAttributes {
      // Specifies the port on the host that is being addressed. Many services only expose a single port or label ports with the protocols they support, in these cases it is not required to explicitly select the port.
      // @ts-ignore
      port?: Input<number>;
      // Names of gateways where the rule should be applied. Gateway names in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway match is independent of sourceLabels.
      // @ts-ignore
      gateways?: Input<Input<string>[]>;
      // One or more labels that constrain the applicability of a rule to workloads with the given labels. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it should include the reserved gateway `mesh` in order for this field to be applicable.
      // @ts-ignore
      sourceLabels?: Input<Record<Input<string>, Input<string>>>;
      // Source namespace constraining the applicability of a rule to workloads in that namespace. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it must include the reserved gateway `mesh` for this field to be applicable.
      // @ts-ignore
      sourceNamespace?: Input<string>;
      // IPv4 or IPv6 ip addresses of destination with optional subnet. E.g., a.b.c.d/xx form or just a.b.c.d.
      // @ts-ignore
      destinationSubnets?: Input<Input<string>[]>;
      // IPv4 or IPv6 ip address of source with optional subnet. E.g., a.b.c.d/xx form or just a.b.c.d $hide_from_docs
      // @ts-ignore
      sourceSubnet?: Input<string>;
    }
    // @ts-ignore
    export interface StringMatch {}
    // @ts-ignore
    export interface Delay {
      // Percentage of requests on which the delay will be injected (0-100). Use of integer `percent` value is deprecated. Use the double `percentage` field instead.
      // @ts-ignore
      percent?: Input<number>;
      // @ts-ignore
      percentage?: Input<Percent>;
    }
    // @ts-ignore
    export interface Abort {
      // @ts-ignore
      percentage?: Input<Percent>;
    }
    // @ts-ignore
    export interface WorkloadEntry {
      // One or more labels associated with the endpoint.
      // @ts-ignore
      labels?: Input<Record<Input<string>, Input<string>>>;
      // Set of ports associated with the endpoint. The ports must be associated with a port name that was declared as part of the service. Do not use for `unix://` addresses.
      // @ts-ignore
      ports?: Input<Record<Input<string>, Input<number>>>;
      // The load balancing weight associated with the endpoint. Endpoints with higher weights will receive proportionally higher traffic.
      // @ts-ignore
      weight?: Input<number>;
      // Address associated with the network endpoint without the port. Domain names can be used if and only if the resolution is set to DNS, and must be fully-qualified without wildcards. Use the form unix:///absolute/path/to/socket for Unix domain socket endpoints.
      // @ts-ignore
      address?: Input<string>;
      // Network enables Istio to group endpoints resident in the same L3 domain/network. All endpoints in the same network are assumed to be directly reachable from one another. When endpoints in different networks cannot reach each other directly, an Istio Gateway can be used to establish connectivity (usually using the `AUTO_PASSTHROUGH` mode in a Gateway Server). This is an advanced configuration used typically for spanning an Istio mesh over multiple clusters.
      // @ts-ignore
      network?: Input<string>;
      // The locality associated with the endpoint. A locality corresponds to a failure domain (e.g., country/region/zone). Arbitrary failure domain hierarchies can be represented by separating each encapsulating failure domain by /. For example, the locality of an an endpoint in US, in US-East-1 region, within availability zone az-1, in data center rack r11 can be represented as us/us-east-1/az-1/r11. Istio will configure the sidecar to route to endpoints within the same locality as the sidecar. If none of the endpoints in the locality are available, endpoints parent locality (but within the same network ID) will be chosen. For example, if there are two endpoints in same network (networkID "n1"), say e1 with locality us/us-east-1/az-1/r11 and e2 with locality us/us-east-1/az-2/r12, a sidecar from us/us-east-1/az-1/r11 locality will prefer e1 from the same locality over e2 from a different locality. Endpoint e2 could be the IP associated with a gateway (that bridges networks n1 and n2), or the IP associated with a standard service endpoint.
      // @ts-ignore
      locality?: Input<string>;
      // The service account associated with the workload if a sidecar is present in the workload. The service account must be present in the same namespace as the configuration ( WorkloadEntry or a ServiceEntry)
      // @ts-ignore
      serviceAccount?: Input<string>;
    }
  }
  export namespace v1beta1 {
    export interface DestinationRuleArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<DestinationRule>;
    }
    // @ts-ignore
    export interface DestinationRule {
      // The name of a service from the service registry. Service names are looked up from the platform's service registry (e.g., Kubernetes services, Consul services, etc.) and from the hosts declared by [ServiceEntries](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry). Rules defined for services that do not exist in the service registry will be ignored.
      // @ts-ignore
      host?: Input<string>;
      // @ts-ignore
      trafficPolicy?: Input<TrafficPolicy>;
      // One or more named sets that represent individual versions of a service. Traffic policies can be overridden at subset level.
      // @ts-ignore
      subsets?: Input<Input<Subset>[]>;
      // A list of namespaces to which this destination rule is exported. The resolution of a destination rule to apply to a service occurs in the context of a hierarchy of namespaces. Exporting a destination rule allows it to be included in the resolution hierarchy for services in other namespaces. This feature provides a mechanism for service owners and mesh administrators to control the visibility of destination rules across namespace boundaries.
      // @ts-ignore
      exportTo?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export interface TrafficPolicy {
      // @ts-ignore
      loadBalancer?: Input<LoadBalancerSettings>;
      // @ts-ignore
      connectionPool?: Input<ConnectionPoolSettings>;
      // @ts-ignore
      outlierDetection?: Input<OutlierDetection>;
      // @ts-ignore
      tls?: Input<ClientTLSSettings>;
      // Traffic policies specific to individual ports. Note that port level settings will override the destination-level settings. Traffic settings specified at the destination-level will not be inherited when overridden by port-level settings, i.e. default values will be applied to fields omitted in port-level traffic policies.
      // @ts-ignore
      portLevelSettings?: Input<Input<PortTrafficPolicy>[]>;
    }
    // @ts-ignore
    export interface Subset {
      // Name of the subset. The service name and the subset name can be used for traffic splitting in a route rule.
      // @ts-ignore
      name?: Input<string>;
      // @ts-ignore
      trafficPolicy?: Input<TrafficPolicy>;
      // Labels apply a filter over the endpoints of a service in the service registry. See route rules for examples of usage.
      // @ts-ignore
      labels?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export interface LoadBalancerSettings {
      // @ts-ignore
      localityLbSetting?: Input<LocalityLoadBalancerSetting>;
    }
    // @ts-ignore
    export interface ConnectionPoolSettings {
      // @ts-ignore
      tcp?: Input<TCPSettings>;
      // @ts-ignore
      http?: Input<HTTPSettings>;
    }
    // @ts-ignore
    export interface OutlierDetection {
      // Time interval between ejection sweep analysis. format: 1h/1m/1s/1ms. MUST BE >=1ms. Default is 10s.
      // @ts-ignore
      interval?: Input<string>;
      // Number of errors before a host is ejected from the connection pool. Defaults to 5. When the upstream host is accessed over HTTP, a 502, 503, or 504 return code qualifies as an error. When the upstream host is accessed over an opaque TCP connection, connect timeouts and connection error/failure events qualify as an error. $hide_from_docs
      // @ts-ignore
      consecutiveErrors?: Input<number>;
      // Number of gateway errors before a host is ejected from the connection pool. When the upstream host is accessed over HTTP, a 502, 503, or 504 return code qualifies as a gateway error. When the upstream host is accessed over an opaque TCP connection, connect timeouts and connection error/failure events qualify as a gateway error. This feature is disabled by default or when set to the value 0.
      // @ts-ignore
      consecutiveGatewayErrors?: Input<number>;
      // Number of 5xx errors before a host is ejected from the connection pool. When the upstream host is accessed over an opaque TCP connection, connect timeouts, connection error/failure and request failure events qualify as a 5xx error. This feature defaults to 5 but can be disabled by setting the value to 0.
      // @ts-ignore
      consecutive5xxErrors?: Input<number>;
      // Minimum ejection duration. A host will remain ejected for a period equal to the product of minimum ejection duration and the number of times the host has been ejected. This technique allows the system to automatically increase the ejection period for unhealthy upstream servers. format: 1h/1m/1s/1ms. MUST BE >=1ms. Default is 30s.
      // @ts-ignore
      baseEjectionTime?: Input<string>;
      // Maximum % of hosts in the load balancing pool for the upstream service that can be ejected. Defaults to 10%.
      // @ts-ignore
      maxEjectionPercent?: Input<number>;
      // Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode. When the percentage of healthy hosts in the load balancing pool drops below this threshold, outlier detection will be disabled and the proxy will load balance across all hosts in the pool (healthy and unhealthy). The threshold can be disabled by setting it to 0%. The default is 0% as it's not typically applicable in k8s environments with few pods per service.
      // @ts-ignore
      minHealthPercent?: Input<number>;
    }
    // @ts-ignore
    export interface ClientTLSSettings {
      // @ts-ignore
      mode?: Input<TLSmode>;
      // REQUIRED if mode is `MUTUAL`. The path to the file holding the client-side TLS certificate to use. Should be empty if mode is `ISTIO_MUTUAL`.
      // @ts-ignore
      clientCertificate: Input<string>;
      // REQUIRED if mode is `MUTUAL`. The path to the file holding the client's private key. Should be empty if mode is `ISTIO_MUTUAL`.
      // @ts-ignore
      privateKey: Input<string>;
      // OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate. If omitted, the proxy will not verify the server's certificate. Should be empty if mode is `ISTIO_MUTUAL`.
      // @ts-ignore
      caCertificates?: Input<string>;
      // A list of alternate names to verify the subject identity in the certificate. If specified, the proxy will verify that the server certificate's subject alt name matches one of the specified values. If specified, this list overrides the value of subject_alt_names from the ServiceEntry.
      // @ts-ignore
      subjectAltNames?: Input<Input<string>[]>;
      // SNI string to present to the server during TLS handshake.
      // @ts-ignore
      sni?: Input<string>;
    }
    // @ts-ignore
    export interface PortTrafficPolicy {
      // @ts-ignore
      loadBalancer?: Input<LoadBalancerSettings>;
      // @ts-ignore
      connectionPool?: Input<ConnectionPoolSettings>;
      // @ts-ignore
      outlierDetection?: Input<OutlierDetection>;
      // @ts-ignore
      tls?: Input<ClientTLSSettings>;
      // @ts-ignore
      port?: Input<PortSelector>;
    }
    // @ts-ignore
    export interface PortSelector {
      // Valid port number
      // @ts-ignore
      number?: Input<number>;
    }
    // @ts-ignore
    export interface LocalityLoadBalancerSetting {
      // Optional: only one of distribute or failover can be set. Explicitly specify loadbalancing weight across different zones and geographical locations. Refer to [Locality weighted load balancing](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/locality_weight) If empty, the locality weight is set according to the endpoints number within it.
      // @ts-ignore
      distribute?: Input<Input<Distribute>[]>;
      // Optional: only failover or distribute can be set. Explicitly specify the region traffic will land on when endpoints in local region becomes unhealthy. Should be used together with OutlierDetection to detect unhealthy endpoints. Note: if no OutlierDetection specified, this will not take effect.
      // @ts-ignore
      failover?: Input<Input<Failover>[]>;
      // enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety. e.g. true means that turn on locality load balancing for this DestinationRule no matter what mesh wide settings is.
      // @ts-ignore
      enabled?: Input<boolean>;
    }
    // @ts-ignore
    export type SimpleLB = Input<'ROUND_ROBIN' | 'LEAST_CONN' | 'RANDOM' | 'PASSTHROUGH'>;
    // @ts-ignore
    export interface ConsistentHashLB {
      // The minimum number of virtual nodes to use for the hash ring. Defaults to 1024. Larger ring sizes result in more granular load distributions. If the number of hosts in the load balancing pool is larger than the ring size, each host will be assigned a single virtual node.
      // @ts-ignore
      minimumRingSize?: Input<number>;
    }
    // @ts-ignore
    export interface HTTPCookie {
      // Path to set for the cookie.
      // @ts-ignore
      path?: Input<string>;
      // Name of the cookie.
      // @ts-ignore
      name?: Input<string>;
      // Lifetime of the cookie.
      // @ts-ignore
      ttl?: Input<string>;
    }
    // @ts-ignore
    export interface TCPSettings {
      // Maximum number of HTTP1 /TCP connections to a destination host. Default 2^32-1.
      // @ts-ignore
      maxConnections?: Input<number>;
      // TCP connection timeout.
      // @ts-ignore
      connectTimeout?: Input<string>;
      // @ts-ignore
      tcpKeepalive?: Input<TcpKeepalive>;
    }
    // @ts-ignore
    export interface HTTPSettings {
      // Maximum number of pending HTTP requests to a destination. Default 2^32-1.
      // @ts-ignore
      http1MaxPendingRequests?: Input<number>;
      // Maximum number of requests to a backend. Default 2^32-1.
      // @ts-ignore
      http2MaxRequests?: Input<number>;
      // Maximum number of requests per connection to a backend. Setting this parameter to 1 disables keep alive. Default 0, meaning "unlimited", up to 2^29.
      // @ts-ignore
      maxRequestsPerConnection?: Input<number>;
      // Maximum number of retries that can be outstanding to all hosts in a cluster at a given time. Defaults to 2^32-1.
      // @ts-ignore
      maxRetries?: Input<number>;
      // The idle timeout for upstream connection pool connections. The idle timeout is defined as the period in which there are no active requests. If not set, the default is 1 hour. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. Applies to both HTTP1.1 and HTTP2 connections.
      // @ts-ignore
      idleTimeout?: Input<string>;
      // @ts-ignore
      h2UpgradePolicy?: Input<H2UpgradePolicy>;
    }
    // @ts-ignore
    export interface TcpKeepalive {
      // The time duration a connection needs to be idle before keep-alive probes start being sent. Default is to use the OS level configuration (unless overridden, Linux defaults to 7200s (ie 2 hours.)
      // @ts-ignore
      time?: Input<string>;
      // Maximum number of keepalive probes to send without response before deciding the connection is dead. Default is to use the OS level configuration (unless overridden, Linux defaults to 9.)
      // @ts-ignore
      probes?: Input<number>;
      // The time duration between keep-alive probes. Default is to use the OS level configuration (unless overridden, Linux defaults to 75s.)
      // @ts-ignore
      interval?: Input<string>;
    }
    // @ts-ignore
    export type H2UpgradePolicy = Input<'DEFAULT' | 'DO_NOT_UPGRADE' | 'UPGRADE'>;
    // @ts-ignore
    export type TLSmode = Input<'DISABLE' | 'SIMPLE' | 'MUTUAL' | 'ISTIO_MUTUAL'>;
    // @ts-ignore
    export interface Distribute {
      // Originating locality, '/' separated, e.g. 'region/zone/sub_zone'.
      // @ts-ignore
      from?: Input<string>;
      // Map of upstream localities to traffic distribution weights. The sum of all weights should be == 100. Any locality not assigned a weight will receive no traffic.
      // @ts-ignore
      to?: Input<Record<Input<string>, Input<number>>>;
    }
    // @ts-ignore
    export interface Failover {
      // Originating region.
      // @ts-ignore
      from?: Input<string>;
      // Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.
      // @ts-ignore
      to?: Input<string>;
    }
    export interface GatewayArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<Gateway>;
    }
    // @ts-ignore
    export interface Gateway {
      // A list of server specifications.
      // @ts-ignore
      servers?: Input<Input<Server>[]>;
      // One or more labels that indicate a specific set of pods/VMs on which this gateway configuration should be applied. The scope of label search is restricted to the configuration namespace in which the the resource is present. In other words, the Gateway resource must reside in the same namespace as the gateway workload instance. If selector is nil, the Gateway will be applied to all workloads.
      // @ts-ignore
      selector?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export interface Server {
      // @ts-ignore
      tls?: Input<ServerTLSSettings>;
      // @ts-ignore
      port?: Input<Port>;
      // The ip or the Unix domain socket to which the listener should be bound to. Format: `x.x.x.x` or `unix:///path/to/uds` or `unix://@foobar` (Linux abstract namespace). When using Unix domain sockets, the port number should be 0.
      // @ts-ignore
      bind?: Input<string>;
      // One or more hosts exposed by this gateway. While typically applicable to HTTP services, it can also be used for TCP services using TLS with SNI. A host is specified as a `dnsName` with an optional `namespace/` prefix. The `dnsName` should be specified using FQDN format, optionally including a wildcard character in the left-most component (e.g., `prod/*.example.com`). Set the `dnsName` to `*` to select all `VirtualService` hosts from the specified namespace (e.g.,`prod/*`).
      // @ts-ignore
      hosts?: Input<Input<string>[]>;
      // The loopback IP endpoint or Unix domain socket to which traffic should be forwarded to by default. Format should be `127.0.0.1:PORT` or `unix:///path/to/socket` or `unix://@foobar` (Linux abstract namespace). NOT IMPLEMENTED. $hide_from_docs
      // @ts-ignore
      defaultEndpoint?: Input<string>;
    }
    // @ts-ignore
    export interface Port {
      // A valid non-negative integer port number.
      // @ts-ignore
      number?: Input<number>;
      // Label assigned to the port.
      // @ts-ignore
      name?: Input<string>;
      // The protocol exposed on the port. MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS. TLS implies the connection will be routed based on the SNI header to the destination without terminating the TLS connection.
      // @ts-ignore
      protocol?: Input<string>;
    }
    // @ts-ignore
    export interface ServerTLSSettings {
      // @ts-ignore
      mode?: Input<TLSmode>;
      // REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file holding the server's private key.
      // @ts-ignore
      privateKey: Input<string>;
      // REQUIRED if mode is `MUTUAL`. The path to a file containing certificate authority certificates to use in verifying a presented client side certificate.
      // @ts-ignore
      caCertificates: Input<string>;
      // A list of alternate names to verify the subject identity in the certificate presented by the client.
      // @ts-ignore
      subjectAltNames?: Input<Input<string>[]>;
      // If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
      // @ts-ignore
      httpsRedirect?: Input<boolean>;
      // REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file holding the server-side TLS certificate to use.
      // @ts-ignore
      serverCertificate: Input<string>;
      // For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates. Applicable only on Kubernetes, and only if the dynamic credential fetching feature is enabled in the proxy by setting `ISTIO_META_USER_SDS` metadata variable. The secret (of type `generic`) should contain the following keys and values: `key: <privateKey>`, `cert: <serverCert>`, `cacert: <CACertificate>`.
      // @ts-ignore
      credentialName?: Input<string>;
      // An optional list of base64-encoded SHA-256 hashes of the SKPIs of authorized client certificates. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.
      // @ts-ignore
      verifyCertificateSpki?: Input<Input<string>[]>;
      // An optional list of hex-encoded SHA-256 hashes of the authorized client certificates. Both simple and colon separated formats are acceptable. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.
      // @ts-ignore
      verifyCertificateHash?: Input<Input<string>[]>;
      // @ts-ignore
      minProtocolVersion?: Input<TLSProtocol>;
      // @ts-ignore
      maxProtocolVersion?: Input<TLSProtocol>;
      // Optional: If specified, only support the specified cipher list. Otherwise default to the default cipher list supported by Envoy.
      // @ts-ignore
      cipherSuites?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export type TLSmode = Input<'PASSTHROUGH' | 'SIMPLE' | 'MUTUAL' | 'AUTO_PASSTHROUGH' | 'ISTIO_MUTUAL'>;
    // @ts-ignore
    export type TLSProtocol = Input<'TLS_AUTO' | 'TLSV1_0' | 'TLSV1_1' | 'TLSV1_2' | 'TLSV1_3'>;
    // @ts-ignore
    export interface Port {
      // A valid non-negative integer port number.
      // @ts-ignore
      number?: Input<number>;
      // Label assigned to the port.
      // @ts-ignore
      name?: Input<string>;
      // The protocol exposed on the port. MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS. TLS implies the connection will be routed based on the SNI header to the destination without terminating the TLS connection.
      // @ts-ignore
      protocol?: Input<string>;
    }
    export interface ServiceEntryArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<ServiceEntry>;
    }
    // @ts-ignore
    export interface ServiceEntry {
      // A list of namespaces to which this service is exported. Exporting a service allows it to be used by sidecars, gateways and virtual services defined in other namespaces. This feature provides a mechanism for service owners and mesh administrators to control the visibility of services across namespace boundaries.
      // @ts-ignore
      exportTo?: Input<Input<string>[]>;
      // If specified, the proxy will verify that the server certificate's subject alternate name matches one of the specified values.
      // @ts-ignore
      subjectAltNames?: Input<Input<string>[]>;
      // The hosts associated with the ServiceEntry. Could be a DNS name with wildcard prefix.
      // @ts-ignore
      hosts?: Input<Input<string>[]>;
      // The virtual IP addresses associated with the service. Could be CIDR prefix. For HTTP traffic, generated route configurations will include http route domains for both the `addresses` and `hosts` field values and the destination will be identified based on the HTTP Host/Authority header. If one or more IP addresses are specified, the incoming traffic will be identified as belonging to this service if the destination IP matches the IP/CIDRs specified in the addresses field. If the Addresses field is empty, traffic will be identified solely based on the destination port. In such scenarios, the port on which the service is being accessed must not be shared by any other service in the mesh. In other words, the sidecar will behave as a simple TCP proxy, forwarding incoming traffic on a specified port to the specified destination endpoint IP/host. Unix domain socket addresses are not supported in this field.
      // @ts-ignore
      addresses?: Input<Input<string>[]>;
      // The ports associated with the external service. If the Endpoints are Unix domain socket addresses, there must be exactly one port.
      // @ts-ignore
      ports?: Input<Input<Port>[]>;
      // @ts-ignore
      location?: Input<Location>;
      // @ts-ignore
      resolution?: Input<Resolution>;
      // One or more endpoints associated with the service. Only one of `endpoints` or `workloadSelector` can be specified.
      // @ts-ignore
      endpoints?: Input<Input<WorkloadEntry>[]>;
      // @ts-ignore
      workloadSelector?: Input<WorkloadSelector>;
    }
    // @ts-ignore
    export type Location = Input<'MESH_EXTERNAL' | 'MESH_INTERNAL'>;
    // @ts-ignore
    export type Resolution = Input<'NONE' | 'STATIC' | 'DNS'>;
    // @ts-ignore
    export interface WorkloadEntry {
      // One or more labels associated with the endpoint.
      // @ts-ignore
      labels?: Input<Record<Input<string>, Input<string>>>;
      // Set of ports associated with the endpoint. The ports must be associated with a port name that was declared as part of the service. Do not use for `unix://` addresses.
      // @ts-ignore
      ports?: Input<Record<Input<string>, Input<number>>>;
      // The load balancing weight associated with the endpoint. Endpoints with higher weights will receive proportionally higher traffic.
      // @ts-ignore
      weight?: Input<number>;
      // Address associated with the network endpoint without the port. Domain names can be used if and only if the resolution is set to DNS, and must be fully-qualified without wildcards. Use the form unix:///absolute/path/to/socket for Unix domain socket endpoints.
      // @ts-ignore
      address?: Input<string>;
      // Network enables Istio to group endpoints resident in the same L3 domain/network. All endpoints in the same network are assumed to be directly reachable from one another. When endpoints in different networks cannot reach each other directly, an Istio Gateway can be used to establish connectivity (usually using the `AUTO_PASSTHROUGH` mode in a Gateway Server). This is an advanced configuration used typically for spanning an Istio mesh over multiple clusters.
      // @ts-ignore
      network?: Input<string>;
      // The locality associated with the endpoint. A locality corresponds to a failure domain (e.g., country/region/zone). Arbitrary failure domain hierarchies can be represented by separating each encapsulating failure domain by /. For example, the locality of an an endpoint in US, in US-East-1 region, within availability zone az-1, in data center rack r11 can be represented as us/us-east-1/az-1/r11. Istio will configure the sidecar to route to endpoints within the same locality as the sidecar. If none of the endpoints in the locality are available, endpoints parent locality (but within the same network ID) will be chosen. For example, if there are two endpoints in same network (networkID "n1"), say e1 with locality us/us-east-1/az-1/r11 and e2 with locality us/us-east-1/az-2/r12, a sidecar from us/us-east-1/az-1/r11 locality will prefer e1 from the same locality over e2 from a different locality. Endpoint e2 could be the IP associated with a gateway (that bridges networks n1 and n2), or the IP associated with a standard service endpoint.
      // @ts-ignore
      locality?: Input<string>;
      // The service account associated with the workload if a sidecar is present in the workload. The service account must be present in the same namespace as the configuration ( WorkloadEntry or a ServiceEntry)
      // @ts-ignore
      serviceAccount?: Input<string>;
    }
    // @ts-ignore
    export interface WorkloadSelector {
      // One or more labels that indicate a specific set of pods/VMs on which this `Sidecar` configuration should be applied. The scope of label search is restricted to the configuration namespace in which the the resource is present.
      // @ts-ignore
      labels?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export interface ClientTLSSettings {
      // @ts-ignore
      mode?: Input<TLSmode>;
      // REQUIRED if mode is `MUTUAL`. The path to the file holding the client-side TLS certificate to use. Should be empty if mode is `ISTIO_MUTUAL`.
      // @ts-ignore
      clientCertificate: Input<string>;
      // REQUIRED if mode is `MUTUAL`. The path to the file holding the client's private key. Should be empty if mode is `ISTIO_MUTUAL`.
      // @ts-ignore
      privateKey: Input<string>;
      // OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate. If omitted, the proxy will not verify the server's certificate. Should be empty if mode is `ISTIO_MUTUAL`.
      // @ts-ignore
      caCertificates?: Input<string>;
      // A list of alternate names to verify the subject identity in the certificate. If specified, the proxy will verify that the server certificate's subject alt name matches one of the specified values. If specified, this list overrides the value of subject_alt_names from the ServiceEntry.
      // @ts-ignore
      subjectAltNames?: Input<Input<string>[]>;
      // SNI string to present to the server during TLS handshake.
      // @ts-ignore
      sni?: Input<string>;
    }
    // @ts-ignore
    export interface PortSelector {
      // Valid port number
      // @ts-ignore
      number?: Input<number>;
    }
    // @ts-ignore
    export type TLSmode = Input<'DISABLE' | 'SIMPLE' | 'MUTUAL' | 'ISTIO_MUTUAL'>;
    // @ts-ignore
    export interface Port {
      // A valid non-negative integer port number.
      // @ts-ignore
      number?: Input<number>;
      // Label assigned to the port.
      // @ts-ignore
      name?: Input<string>;
      // The protocol exposed on the port. MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP|TLS. TLS implies the connection will be routed based on the SNI header to the destination without terminating the TLS connection.
      // @ts-ignore
      protocol?: Input<string>;
    }
    // @ts-ignore
    export interface ServerTLSSettings {
      // @ts-ignore
      mode?: Input<TLSmode>;
      // REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file holding the server's private key.
      // @ts-ignore
      privateKey: Input<string>;
      // REQUIRED if mode is `MUTUAL`. The path to a file containing certificate authority certificates to use in verifying a presented client side certificate.
      // @ts-ignore
      caCertificates: Input<string>;
      // A list of alternate names to verify the subject identity in the certificate presented by the client.
      // @ts-ignore
      subjectAltNames?: Input<Input<string>[]>;
      // If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
      // @ts-ignore
      httpsRedirect?: Input<boolean>;
      // REQUIRED if mode is `SIMPLE` or `MUTUAL`. The path to the file holding the server-side TLS certificate to use.
      // @ts-ignore
      serverCertificate: Input<string>;
      // For gateways running on Kubernetes, the name of the secret that holds the TLS certs including the CA certificates. Applicable only on Kubernetes, and only if the dynamic credential fetching feature is enabled in the proxy by setting `ISTIO_META_USER_SDS` metadata variable. The secret (of type `generic`) should contain the following keys and values: `key: <privateKey>`, `cert: <serverCert>`, `cacert: <CACertificate>`.
      // @ts-ignore
      credentialName?: Input<string>;
      // An optional list of base64-encoded SHA-256 hashes of the SKPIs of authorized client certificates. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.
      // @ts-ignore
      verifyCertificateSpki?: Input<Input<string>[]>;
      // An optional list of hex-encoded SHA-256 hashes of the authorized client certificates. Both simple and colon separated formats are acceptable. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.
      // @ts-ignore
      verifyCertificateHash?: Input<Input<string>[]>;
      // @ts-ignore
      minProtocolVersion?: Input<TLSProtocol>;
      // @ts-ignore
      maxProtocolVersion?: Input<TLSProtocol>;
      // Optional: If specified, only support the specified cipher list. Otherwise default to the default cipher list supported by Envoy.
      // @ts-ignore
      cipherSuites?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export type TLSmode = Input<'PASSTHROUGH' | 'SIMPLE' | 'MUTUAL' | 'AUTO_PASSTHROUGH' | 'ISTIO_MUTUAL'>;
    // @ts-ignore
    export type TLSProtocol = Input<'TLS_AUTO' | 'TLSV1_0' | 'TLSV1_1' | 'TLSV1_2' | 'TLSV1_3'>;
    // @ts-ignore
    export interface WorkloadSelector {
      // One or more labels that indicate a specific set of pods/VMs on which this `Sidecar` configuration should be applied. The scope of label search is restricted to the configuration namespace in which the the resource is present.
      // @ts-ignore
      labels?: Input<Record<Input<string>, Input<string>>>;
    }
    export interface SidecarArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<Sidecar>;
    }
    // @ts-ignore
    export interface Sidecar {
      // @ts-ignore
      workloadSelector?: Input<WorkloadSelector>;
      // Ingress specifies the configuration of the sidecar for processing inbound traffic to the attached workload instance. If omitted, Istio will automatically configure the sidecar based on the information about the workload obtained from the orchestration platform (e.g., exposed ports, services, etc.). If specified, inbound ports are configured if and only if the workload instance is associated with a service.
      // @ts-ignore
      ingress?: Input<Input<IstioIngressListener>[]>;
      // Egress specifies the configuration of the sidecar for processing outbound traffic from the attached workload instance to other services in the mesh. If not specified, inherits the system detected defaults from the namespace-wide or the global default Sidecar.
      // @ts-ignore
      egress?: Input<Input<IstioEgressListener>[]>;
      // @ts-ignore
      outboundTrafficPolicy?: Input<OutboundTrafficPolicy>;
      // @ts-ignore
      localhost?: Input<Localhost>;
    }
    // @ts-ignore
    export interface IstioIngressListener {
      // @ts-ignore
      port?: Input<Port>;
      // The IP to which the listener should be bound. Must be in the format `x.x.x.x`. Unix domain socket addresses are not allowed in the bind field for ingress listeners. If omitted, Istio will automatically configure the defaults based on imported services and the workload instances to which this configuration is applied to.
      // @ts-ignore
      bind?: Input<string>;
      // The loopback IP endpoint or Unix domain socket to which traffic should be forwarded to. This configuration can be used to redirect traffic arriving at the bind `IP:Port` on the sidecar to a `localhost:port` or Unix domain socket where the application workload instance is listening for connections. Format should be `127.0.0.1:PORT` or `unix:///path/to/socket`
      // @ts-ignore
      defaultEndpoint?: Input<string>;
      // @ts-ignore
      captureMode?: Input<CaptureMode>;
      // @ts-ignore
      localhostClientTls?: Input<ClientTLSSettings>;
    }
    // @ts-ignore
    export interface IstioEgressListener {
      // @ts-ignore
      port?: Input<Port>;
      // The IP or the Unix domain socket to which the listener should be bound to. Port MUST be specified if bind is not empty. Format: `x.x.x.x` or `unix:///path/to/uds` or `unix://@foobar` (Linux abstract namespace). If omitted, Istio will automatically configure the defaults based on imported services, the workload instances to which this configuration is applied to and the captureMode. If captureMode is `NONE`, bind will default to 127.0.0.1.
      // @ts-ignore
      bind?: Input<string>;
      // One or more service hosts exposed by the listener in `namespace/dnsName` format. Services in the specified namespace matching `dnsName` will be exposed. The corresponding service can be a service in the service registry (e.g., a Kubernetes or cloud foundry service) or a service specified using a `ServiceEntry` or `VirtualService` configuration. Any associated `DestinationRule` in the same namespace will also be used.
      // @ts-ignore
      hosts?: Input<Input<string>[]>;
      // @ts-ignore
      captureMode?: Input<CaptureMode>;
      // @ts-ignore
      localhostServerTls?: Input<ServerTLSSettings>;
    }
    // @ts-ignore
    export interface OutboundTrafficPolicy {
      // @ts-ignore
      mode?: Input<Mode>;
      // @ts-ignore
      egressProxy?: Input<Destination>;
    }
    // @ts-ignore
    export interface Localhost {
      // @ts-ignore
      clientTls?: Input<ClientTLSSettings>;
      // @ts-ignore
      serverTls?: Input<ServerTLSSettings>;
    }
    // @ts-ignore
    export type CaptureMode = Input<'DEFAULT' | 'IPTABLES' | 'NONE'>;
    // @ts-ignore
    export type Mode = Input<'REGISTRY_ONLY' | 'ALLOW_ANY'>;
    // @ts-ignore
    export interface Destination {
      // The name of a service from the service registry. Service names are looked up from the platform's service registry (e.g., Kubernetes services, Consul services, etc.) and from the hosts declared by [ServiceEntry](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry). Traffic forwarded to destinations that are not found in either of the two, will be dropped.
      // @ts-ignore
      host?: Input<string>;
      // @ts-ignore
      port?: Input<PortSelector>;
      // The name of a subset within the service. Applicable only to services within the mesh. The subset must be defined in a corresponding DestinationRule.
      // @ts-ignore
      subset?: Input<string>;
    }
    // @ts-ignore
    export interface PortSelector {
      // Valid port number
      // @ts-ignore
      number?: Input<number>;
    }
    // @ts-ignore
    export interface Destination {
      // The name of a service from the service registry. Service names are looked up from the platform's service registry (e.g., Kubernetes services, Consul services, etc.) and from the hosts declared by [ServiceEntry](https://istio.io/docs/reference/config/networking/service-entry/#ServiceEntry). Traffic forwarded to destinations that are not found in either of the two, will be dropped.
      // @ts-ignore
      host?: Input<string>;
      // @ts-ignore
      port?: Input<PortSelector>;
      // The name of a subset within the service. Applicable only to services within the mesh. The subset must be defined in a corresponding DestinationRule.
      // @ts-ignore
      subset?: Input<string>;
    }
    export interface VirtualServiceArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<VirtualService>;
    }
    // @ts-ignore
    export interface VirtualService {
      // A list of namespaces to which this virtual service is exported. Exporting a virtual service allows it to be used by sidecars and gateways defined in other namespaces. This feature provides a mechanism for service owners and mesh administrators to control the visibility of virtual services across namespace boundaries.
      // @ts-ignore
      exportTo?: Input<Input<string>[]>;
      // An ordered list of route rule for non-terminated TLS & HTTPS traffic. Routing is typically performed using the SNI value presented by the ClientHello message. TLS routes will be applied to platform service ports named 'https-*', 'tls-*', unterminated gateway ports using HTTPS/TLS protocols (i.e. with "passthrough" TLS mode) and service entry ports using HTTPS/TLS protocols. The first rule matching an incoming request is used. NOTE: Traffic 'https-*' or 'tls-*' ports without associated virtual service will be treated as opaque TCP traffic.
      // @ts-ignore
      tls?: Input<Input<TLSRoute>[]>;
      // An ordered list of route rules for opaque TCP traffic. TCP routes will be applied to any port that is not a HTTP or TLS port. The first rule matching an incoming request is used.
      // @ts-ignore
      tcp?: Input<Input<TCPRoute>[]>;
      // An ordered list of route rules for HTTP traffic. HTTP routes will be applied to platform service ports named 'http-*'/'http2-*'/'grpc-*', gateway ports with protocol HTTP/HTTP2/GRPC/ TLS-terminated-HTTPS and service entry ports using HTTP/HTTP2/GRPC protocols. The first rule matching an incoming request is used.
      // @ts-ignore
      http?: Input<Input<HTTPRoute>[]>;
      // The destination hosts to which traffic is being sent. Could be a DNS name with wildcard prefix or an IP address. Depending on the platform, short-names can also be used instead of a FQDN (i.e. has no dots in the name). In such a scenario, the FQDN of the host would be derived based on the underlying platform.
      // @ts-ignore
      hosts?: Input<Input<string>[]>;
      // The names of gateways and sidecars that should apply these routes. Gateways in other namespaces may be referred to by `<gateway namespace>/<gateway name>`; specifying a gateway with no namespace qualifier is the same as specifying the VirtualService's namespace. A single VirtualService is used for sidecars inside the mesh as well as for one or more gateways. The selection condition imposed by this field can be overridden using the source field in the match conditions of protocol-specific routes. The reserved word `mesh` is used to imply all the sidecars in the mesh. When this field is omitted, the default gateway (`mesh`) will be used, which would apply the rule to all sidecars in the mesh. If a list of gateway names is provided, the rules will apply only to the gateways. To apply the rules to both gateways and sidecars, specify `mesh` as one of the gateway names.
      // @ts-ignore
      gateways?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export interface HTTPRoute {
      // The name assigned to the route for debugging purposes. The route's name will be concatenated with the match's name and will be logged in the access logs for requests matching this route/match.
      // @ts-ignore
      name?: Input<string>;
      // Match conditions to be satisfied for the rule to be activated. All conditions inside a single match block have AND semantics, while the list of match blocks have OR semantics. The rule is matched if any one of the match blocks succeed.
      // @ts-ignore
      match?: Input<Input<HTTPMatchRequest>[]>;
      // A HTTP rule can either redirect or forward (default) traffic. The forwarding target can be one of several versions of a service (see glossary in beginning of document). Weights associated with the service version determine the proportion of traffic it receives.
      // @ts-ignore
      route?: Input<Input<HTTPRouteDestination>[]>;
      // @ts-ignore
      redirect?: Input<HTTPRedirect>;
      // @ts-ignore
      delegate?: Input<Delegate>;
      // @ts-ignore
      rewrite?: Input<HTTPRewrite>;
      // Timeout for HTTP requests.
      // @ts-ignore
      timeout?: Input<string>;
      // @ts-ignore
      retries?: Input<HTTPRetry>;
      // @ts-ignore
      fault?: Input<HTTPFaultInjection>;
      // @ts-ignore
      mirror?: Input<Destination>;
      // Percentage of the traffic to be mirrored by the `mirror` field. Use of integer `mirror_percent` value is deprecated. Use the double `mirror_percentage` field instead
      // @ts-ignore
      mirrorPercent?: Input<number>;
      // @ts-ignore
      mirrorPercentage?: Input<Percent>;
      // @ts-ignore
      corsPolicy?: Input<CorsPolicy>;
      // @ts-ignore
      headers?: Input<Headers>;
    }
    // @ts-ignore
    export interface TLSRoute {
      // Match conditions to be satisfied for the rule to be activated. All conditions inside a single match block have AND semantics, while the list of match blocks have OR semantics. The rule is matched if any one of the match blocks succeed.
      // @ts-ignore
      match?: Input<Input<TLSMatchAttributes>[]>;
      // The destination to which the connection should be forwarded to.
      // @ts-ignore
      route?: Input<Input<RouteDestination>[]>;
    }
    // @ts-ignore
    export interface TCPRoute {
      // Match conditions to be satisfied for the rule to be activated. All conditions inside a single match block have AND semantics, while the list of match blocks have OR semantics. The rule is matched if any one of the match blocks succeed.
      // @ts-ignore
      match?: Input<Input<L4MatchAttributes>[]>;
      // The destination to which the connection should be forwarded to.
      // @ts-ignore
      route?: Input<Input<RouteDestination>[]>;
    }
    // @ts-ignore
    export interface HTTPMatchRequest {
      // The name assigned to a match. The match's name will be concatenated with the parent route's name and will be logged in the access logs for requests matching this route.
      // @ts-ignore
      name?: Input<string>;
      // @ts-ignore
      method?: Input<StringMatch>;
      // Specifies the ports on the host that is being addressed. Many services only expose a single port or label ports with the protocols they support, in these cases it is not required to explicitly select the port.
      // @ts-ignore
      port?: Input<number>;
      // Names of gateways where the rule should be applied. Gateway names in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway match is independent of sourceLabels.
      // @ts-ignore
      gateways?: Input<Input<string>[]>;
      // The header keys must be lowercase and use hyphen as the separator, e.g. _x-request-id_.
      // @ts-ignore
      headers?: Input<Record<Input<string>, Input<StringMatch>>>;
      // @ts-ignore
      uri?: Input<StringMatch>;
      // @ts-ignore
      scheme?: Input<StringMatch>;
      // @ts-ignore
      authority?: Input<StringMatch>;
      // One or more labels that constrain the applicability of a rule to workloads with the given labels. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it must include the reserved gateway `mesh` for this field to be applicable.
      // @ts-ignore
      sourceLabels?: Input<Record<Input<string>, Input<string>>>;
      // Query parameters for matching.
      // @ts-ignore
      queryParams?: Input<Record<Input<string>, Input<StringMatch>>>;
      // Flag to specify whether the URI matching should be case-insensitive.
      // @ts-ignore
      ignoreUriCase?: Input<boolean>;
      // withoutHeader has the same syntax with the header, but has opposite meaning. If a header is matched with a matching rule among withoutHeader, the traffic becomes not matched one.
      // @ts-ignore
      withoutHeaders?: Input<Record<Input<string>, Input<StringMatch>>>;
      // Source namespace constraining the applicability of a rule to workloads in that namespace. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it must include the reserved gateway `mesh` for this field to be applicable.
      // @ts-ignore
      sourceNamespace?: Input<string>;
    }
    // @ts-ignore
    export interface HTTPRouteDestination {
      // @ts-ignore
      headers?: Input<Headers>;
      // @ts-ignore
      destination?: Input<Destination>;
      // The proportion of traffic to be forwarded to the service version. (0-100). Sum of weights across destinations SHOULD BE == 100. If there is only one destination in a rule, the weight value is assumed to be 100.
      // @ts-ignore
      weight?: Input<number>;
    }
    // @ts-ignore
    export interface HTTPRedirect {
      // On a redirect, overwrite the Path portion of the URL with this value. Note that the entire path will be replaced, irrespective of the request URI being matched as an exact path or prefix.
      // @ts-ignore
      uri?: Input<string>;
      // On a redirect, overwrite the Authority/Host portion of the URL with this value.
      // @ts-ignore
      authority?: Input<string>;
      // On a redirect, Specifies the HTTP status code to use in the redirect response. The default response code is MOVED_PERMANENTLY (301).
      // @ts-ignore
      redirectCode?: Input<number>;
    }
    // @ts-ignore
    export interface Delegate {
      // Name specifies the name of the delegate VirtualService.
      // @ts-ignore
      name?: Input<string>;
      // Namespace specifies the namespace where the delegate VirtualService resides. By default, it is same to the root's.
      // @ts-ignore
      namespace?: Input<string>;
    }
    // @ts-ignore
    export interface HTTPRewrite {
      // rewrite the path (or the prefix) portion of the URI with this value. If the original URI was matched based on prefix, the value provided in this field will replace the corresponding matched prefix.
      // @ts-ignore
      uri?: Input<string>;
      // rewrite the Authority/Host header with this value.
      // @ts-ignore
      authority?: Input<string>;
    }
    // @ts-ignore
    export interface HTTPRetry {
      // Number of retries for a given request. The interval between retries will be determined automatically (25ms+). Actual number of retries attempted depends on the request `timeout` of the [HTTP route](https://istio.io/docs/reference/config/networking/virtual-service/#HTTPRoute).
      // @ts-ignore
      attempts?: Input<number>;
      // Timeout per retry attempt for a given request. format: 1h/1m/1s/1ms. MUST BE >=1ms.
      // @ts-ignore
      perTryTimeout?: Input<string>;
      // Specifies the conditions under which retry takes place. One or more policies can be specified using a , delimited list. See the [retry policies](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on) and [gRPC retry policies](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on) for more details.
      // @ts-ignore
      retryOn?: Input<string>;
      // Flag to specify whether the retries should retry to other localities. See the [retry plugin configuration](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/http_connection_management#retry-plugin-configuration) for more details.
      // @ts-ignore
      retryRemoteLocalities?: Input<boolean>;
    }
    // @ts-ignore
    export interface HTTPFaultInjection {
      // @ts-ignore
      delay?: Input<Delay>;
      // @ts-ignore
      abort?: Input<Abort>;
    }
    // @ts-ignore
    export interface Percent {
      // @ts-ignore
      value?: Input<number>;
    }
    // @ts-ignore
    export interface CorsPolicy {
      // The list of origins that are allowed to perform CORS requests. The content will be serialized into the Access-Control-Allow-Origin header. Wildcard * will allow all origins. $hide_from_docs
      // @ts-ignore
      allowOrigin?: Input<Input<string>[]>;
      // String patterns that match allowed origins. An origin is allowed if any of the string matchers match. If a match is found, then the outgoing Access-Control-Allow-Origin would be set to the origin as provided by the client.
      // @ts-ignore
      allowOrigins?: Input<Input<StringMatch>[]>;
      // List of HTTP methods allowed to access the resource. The content will be serialized into the Access-Control-Allow-Methods header.
      // @ts-ignore
      allowMethods?: Input<Input<string>[]>;
      // List of HTTP headers that can be used when requesting the resource. Serialized to Access-Control-Allow-Headers header.
      // @ts-ignore
      allowHeaders?: Input<Input<string>[]>;
      // A white list of HTTP headers that the browsers are allowed to access. Serialized into Access-Control-Expose-Headers header.
      // @ts-ignore
      exposeHeaders?: Input<Input<string>[]>;
      // Specifies how long the results of a preflight request can be cached. Translates to the `Access-Control-Max-Age` header.
      // @ts-ignore
      maxAge?: Input<string>;
      // Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials. Translates to `Access-Control-Allow-Credentials` header.
      // @ts-ignore
      allowCredentials?: Input<boolean>;
    }
    // @ts-ignore
    export interface Headers {
      // @ts-ignore
      response?: Input<HeaderOperations>;
      // @ts-ignore
      request?: Input<HeaderOperations>;
    }
    // @ts-ignore
    export interface HeaderOperations {
      // Overwrite the headers specified by key with the given values
      // @ts-ignore
      set?: Input<Record<Input<string>, Input<string>>>;
      // Append the given values to the headers specified by keys (will create a comma-separated list of values)
      // @ts-ignore
      add?: Input<Record<Input<string>, Input<string>>>;
      // Remove a the specified headers
      // @ts-ignore
      remove?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export interface TLSMatchAttributes {
      // Specifies the port on the host that is being addressed. Many services only expose a single port or label ports with the protocols they support, in these cases it is not required to explicitly select the port.
      // @ts-ignore
      port?: Input<number>;
      // Names of gateways where the rule should be applied. Gateway names in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway match is independent of sourceLabels.
      // @ts-ignore
      gateways?: Input<Input<string>[]>;
      // One or more labels that constrain the applicability of a rule to workloads with the given labels. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it should include the reserved gateway `mesh` in order for this field to be applicable.
      // @ts-ignore
      sourceLabels?: Input<Record<Input<string>, Input<string>>>;
      // Source namespace constraining the applicability of a rule to workloads in that namespace. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it must include the reserved gateway `mesh` for this field to be applicable.
      // @ts-ignore
      sourceNamespace?: Input<string>;
      // IPv4 or IPv6 ip addresses of destination with optional subnet. E.g., a.b.c.d/xx form or just a.b.c.d.
      // @ts-ignore
      destinationSubnets?: Input<Input<string>[]>;
      // SNI (server name indicator) to match on. Wildcard prefixes can be used in the SNI value, e.g., *.com will match foo.example.com as well as example.com. An SNI value must be a subset (i.e., fall within the domain) of the corresponding virtual serivce's hosts.
      // @ts-ignore
      sniHosts?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export interface RouteDestination {
      // @ts-ignore
      destination?: Input<Destination>;
      // The proportion of traffic to be forwarded to the service version. If there is only one destination in a rule, all traffic will be routed to it irrespective of the weight.
      // @ts-ignore
      weight?: Input<number>;
    }
    // @ts-ignore
    export interface L4MatchAttributes {
      // Specifies the port on the host that is being addressed. Many services only expose a single port or label ports with the protocols they support, in these cases it is not required to explicitly select the port.
      // @ts-ignore
      port?: Input<number>;
      // Names of gateways where the rule should be applied. Gateway names in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway match is independent of sourceLabels.
      // @ts-ignore
      gateways?: Input<Input<string>[]>;
      // One or more labels that constrain the applicability of a rule to workloads with the given labels. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it should include the reserved gateway `mesh` in order for this field to be applicable.
      // @ts-ignore
      sourceLabels?: Input<Record<Input<string>, Input<string>>>;
      // Source namespace constraining the applicability of a rule to workloads in that namespace. If the VirtualService has a list of gateways specified in the top-level `gateways` field, it must include the reserved gateway `mesh` for this field to be applicable.
      // @ts-ignore
      sourceNamespace?: Input<string>;
      // IPv4 or IPv6 ip addresses of destination with optional subnet. E.g., a.b.c.d/xx form or just a.b.c.d.
      // @ts-ignore
      destinationSubnets?: Input<Input<string>[]>;
      // IPv4 or IPv6 ip address of source with optional subnet. E.g., a.b.c.d/xx form or just a.b.c.d $hide_from_docs
      // @ts-ignore
      sourceSubnet?: Input<string>;
    }
    // @ts-ignore
    export interface StringMatch {}
    // @ts-ignore
    export interface Delay {
      // Percentage of requests on which the delay will be injected (0-100). Use of integer `percent` value is deprecated. Use the double `percentage` field instead.
      // @ts-ignore
      percent?: Input<number>;
      // @ts-ignore
      percentage?: Input<Percent>;
    }
    // @ts-ignore
    export interface Abort {
      // @ts-ignore
      percentage?: Input<Percent>;
    }
    // @ts-ignore
    export interface WorkloadEntry {
      // One or more labels associated with the endpoint.
      // @ts-ignore
      labels?: Input<Record<Input<string>, Input<string>>>;
      // Set of ports associated with the endpoint. The ports must be associated with a port name that was declared as part of the service. Do not use for `unix://` addresses.
      // @ts-ignore
      ports?: Input<Record<Input<string>, Input<number>>>;
      // The load balancing weight associated with the endpoint. Endpoints with higher weights will receive proportionally higher traffic.
      // @ts-ignore
      weight?: Input<number>;
      // Address associated with the network endpoint without the port. Domain names can be used if and only if the resolution is set to DNS, and must be fully-qualified without wildcards. Use the form unix:///absolute/path/to/socket for Unix domain socket endpoints.
      // @ts-ignore
      address?: Input<string>;
      // Network enables Istio to group endpoints resident in the same L3 domain/network. All endpoints in the same network are assumed to be directly reachable from one another. When endpoints in different networks cannot reach each other directly, an Istio Gateway can be used to establish connectivity (usually using the `AUTO_PASSTHROUGH` mode in a Gateway Server). This is an advanced configuration used typically for spanning an Istio mesh over multiple clusters.
      // @ts-ignore
      network?: Input<string>;
      // The locality associated with the endpoint. A locality corresponds to a failure domain (e.g., country/region/zone). Arbitrary failure domain hierarchies can be represented by separating each encapsulating failure domain by /. For example, the locality of an an endpoint in US, in US-East-1 region, within availability zone az-1, in data center rack r11 can be represented as us/us-east-1/az-1/r11. Istio will configure the sidecar to route to endpoints within the same locality as the sidecar. If none of the endpoints in the locality are available, endpoints parent locality (but within the same network ID) will be chosen. For example, if there are two endpoints in same network (networkID "n1"), say e1 with locality us/us-east-1/az-1/r11 and e2 with locality us/us-east-1/az-2/r12, a sidecar from us/us-east-1/az-1/r11 locality will prefer e1 from the same locality over e2 from a different locality. Endpoint e2 could be the IP associated with a gateway (that bridges networks n1 and n2), or the IP associated with a standard service endpoint.
      // @ts-ignore
      locality?: Input<string>;
      // The service account associated with the workload if a sidecar is present in the workload. The service account must be present in the same namespace as the configuration ( WorkloadEntry or a ServiceEntry)
      // @ts-ignore
      serviceAccount?: Input<string>;
    }
  }
}

export namespace policy {
  export namespace v1beta1 {
    // @ts-ignore
    export interface Duration {
      // Duration encoded as google.protobuf.Duration.
      // @ts-ignore
      value?: Input<string>;
    }
    // @ts-ignore
    export interface Value {}
    // @ts-ignore
    export interface AttributeManifest {
      // Name of the component producing these attributes. This can be the proxy (with the canonical name `istio-proxy`) or the name of an `attributes` kind adapter in Mixer.
      // @ts-ignore
      name?: Input<string>;
      // The revision of this document. Assigned by server.
      // @ts-ignore
      revision?: Input<string>;
      // The set of attributes this Istio component will be responsible for producing at runtime. We map from attribute name to the attribute's specification. The name of an attribute, which is how attributes are referred to in aspect configuration, must conform to: Name = IDENT { SEPARATOR IDENT };
      // @ts-ignore
      attributes?: Input<Record<Input<string>, Input<AttributeInfo>>>;
    }
    // @ts-ignore
    export interface AttributeInfo {
      // A human-readable description of the attribute's purpose.
      // @ts-ignore
      description?: Input<string>;
      // @ts-ignore
      valueType?: Input<ValueType>;
    }
    // @ts-ignore
    export type ValueType = Input<
      | 'VALUE_TYPE_UNSPECIFIED'
      | 'STRING'
      | 'INT64'
      | 'DOUBLE'
      | 'BOOL'
      | 'TIMESTAMP'
      | 'IP_ADDRESS'
      | 'EMAIL_ADDRESS'
      | 'URI'
      | 'DNS_NAME'
      | 'DURATION'
      | 'STRING_MAP'
    >;
    export interface RuleArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<Rule>;
    }
    // @ts-ignore
    export interface Rule {
      // Match is an attribute based predicate. When Mixer receives a request it evaluates the match expression and executes all the associated `actions` if the match evaluates to true.
      // @ts-ignore
      match?: Input<string>;
      // The actions that will be executed when match evaluates to `true`.
      // @ts-ignore
      actions?: Input<Input<Action>[]>;
      // Templatized operations on the request headers using values produced by the rule actions. Require the check action result to be OK.
      // @ts-ignore
      requestHeaderOperations?: Input<Input<HeaderOperationTemplate>[]>;
      // Templatized operations on the response headers using values produced by the rule actions. Require the check action result to be OK.
      // @ts-ignore
      responseHeaderOperations?: Input<Input<HeaderOperationTemplate>[]>;
      // @ts-ignore
      sampling?: Input<Sampling>;
    }
    // @ts-ignore
    export interface Action {
      // A handle to refer to the results of the action.
      // @ts-ignore
      name?: Input<string>;
      // Fully qualified name of the handler to invoke. Must match the `name` of a [Handler][istio.policy.v1beta1.Handler.name].
      // @ts-ignore
      handler?: Input<string>;
      // Each value must match the fully qualified name of the [Instance][istio.policy.v1beta1.Instance.name]s. Referenced instances are evaluated by resolving the attributes/literals for all the fields. The constructed objects are then passed to the `handler` referenced within this action.
      // @ts-ignore
      instances?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export interface HeaderOperationTemplate {
      // Header name literal value.
      // @ts-ignore
      name?: Input<string>;
      // Header value expressions.
      // @ts-ignore
      values?: Input<Input<string>[]>;
      // @ts-ignore
      operation?: Input<Operation>;
    }
    // @ts-ignore
    export interface Sampling {
      // @ts-ignore
      random?: Input<RandomSampling>;
      // @ts-ignore
      rateLimit?: Input<RateLimitSampling>;
    }
    // @ts-ignore
    export type Operation = Input<'REPLACE' | 'REMOVE' | 'APPEND'>;
    export interface InstanceArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<Instance>;
    }
    // @ts-ignore
    export interface Instance {
      // The name of this instance
      // @ts-ignore
      name?: Input<string>;
      // The name of the compiled in template this instance creates instances for. For referencing non compiled-in templates, use the `template` field instead.
      // @ts-ignore
      compiledTemplate?: Input<string>;
      // The name of the template this instance creates instances for. For referencing compiled-in templates, use the `compiled_template` field instead.
      // @ts-ignore
      template?: Input<string>;
      // Depends on referenced template. Struct representation of a proto defined by the template; this varies depending on the value of field `template`.
      // @ts-ignore
      params?: Input<object>;
      // Defines attribute bindings to map the output of attribute-producing adapters back into the attribute space. The variable `output` refers to the output template instance produced by the adapter. The following example derives `source.namespace` from `source.uid` in the context of Kubernetes: ```yaml params: # Pass the required attribute data to the adapter source_uid: source.uid | "" attribute_bindings: # Fill the new attributes from the adapter produced output source.namespace: output.source_namespace ```
      // @ts-ignore
      attributeBindings?: Input<Record<Input<string>, Input<string>>>;
    }
    export interface HandlerArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<Handler>;
    }
    // @ts-ignore
    export interface Handler {
      // Must be unique in the entire Mixer configuration. Used by [Actions][istio.policy.v1beta1.Action.handler] to refer to this handler.
      // @ts-ignore
      name?: Input<string>;
      // Depends on adapter implementation. Struct representation of a proto defined by the adapter implementation; this varies depending on the value of field `adapter`.
      // @ts-ignore
      params?: Input<object>;
      // The name of the compiled in adapter this handler instantiates. For referencing non compiled-in adapters, use the `adapter` field instead.
      // @ts-ignore
      compiledAdapter?: Input<string>;
      // The name of a specific adapter implementation. For referencing compiled-in adapters, use the `compiled_adapter` field instead.
      // @ts-ignore
      adapter?: Input<string>;
      // @ts-ignore
      connection?: Input<Connection>;
    }
    // @ts-ignore
    export interface Connection {
      // The address of the backend.
      // @ts-ignore
      address?: Input<string>;
      // Timeout for remote calls to the backend.
      // @ts-ignore
      timeout?: Input<string>;
      // @ts-ignore
      authentication?: Input<Authentication>;
    }
    // @ts-ignore
    export interface Authentication {}
    // @ts-ignore
    export interface RandomSampling {
      // Specifies an attribute expression to use to override the numerator in the `percent_sampled` field. If this value is set, but no value is found OR if that value is not a numeric value, then the derived sampling rate will be 0 (meaning no `Action`s are executed for a `Rule`).
      // @ts-ignore
      attributeExpression?: Input<string>;
      // @ts-ignore
      percentSampled?: Input<FractionalPercent>;
      // By default sampling will be based on the value of the request header `x-request-id`. This behavior will cause consistent sampling across `Rule`s and for the full trace of a request through a mesh (across hosts). If that value is not present and/or `use_independent_randomness` is set to true, the sampling will be done based on the value of attribute specified in `attribute_epxression`. If that attribute does not exist, the system will behave as if the sampling rate was 0 (meaning no `Action`s are executed for a `Rule`).
      // @ts-ignore
      useIndependentRandomness?: Input<boolean>;
    }
    // @ts-ignore
    export interface RateLimitSampling {
      // Window in which to enforce the sampling rate.
      // @ts-ignore
      samplingDuration?: Input<string>;
      // Number of entries to allow during the `sampling_duration` before sampling is enforced.
      // @ts-ignore
      maxUnsampledEntries?: Input<number>;
      // The rate at which to sample entries once the unsampled limit has been reached. Sampling will be enforced as 1 per every `sampling_rate` entries allowed.
      // @ts-ignore
      samplingRate?: Input<number>;
    }
    // @ts-ignore
    export interface FractionalPercent {
      // Specifies the numerator. Defaults to 0.
      // @ts-ignore
      numerator?: Input<number>;
      // @ts-ignore
      denominator?: Input<DenominatorType>;
    }
    // @ts-ignore
    export type DenominatorType = Input<'HUNDRED' | 'TEN_THOUSAND'>;
    // @ts-ignore
    export interface Tls {
      // The path to the file holding additional CA certificates to well known public certs.
      // @ts-ignore
      caCertificates?: Input<string>;
      // Used to configure mixer TLS client to verify the hostname on the returned certificates. It is also included in the client's handshake to support SNI.
      // @ts-ignore
      serverName?: Input<string>;
    }
    // @ts-ignore
    export interface Mutual {
      // The path to the file holding additional CA certificates that are needed to verify the presented adapter certificates. By default Mixer should already include Istio CA certificates and system certificates in cert pool.
      // @ts-ignore
      caCertificates?: Input<string>;
      // Used to configure mixer mutual TLS client to supply server name for SNI. It is not used to verify the hostname of the peer certificate, since Istio verifies whitelisted SAN fields in mutual TLS.
      // @ts-ignore
      serverName?: Input<string>;
      // The path to the file holding the private key for mutual TLS. If omitted, the default Mixer private key will be used.
      // @ts-ignore
      privateKey?: Input<string>;
      // The path to the file holding client certificate for mutual TLS. If omitted, the default Mixer certificates will be used.
      // @ts-ignore
      clientCertificate?: Input<string>;
    }
    // @ts-ignore
    export interface OAuth {
      // OAuth client id for mixer.
      // @ts-ignore
      clientId?: Input<string>;
      // The path to the file holding the client secret for oauth.
      // @ts-ignore
      clientSecret?: Input<string>;
      // The Resource server's token endpoint URL.
      // @ts-ignore
      tokenUrl?: Input<string>;
      // List of requested permissions.
      // @ts-ignore
      scopes?: Input<Input<string>[]>;
      // Additional parameters for requests to the token endpoint.
      // @ts-ignore
      endpointParams?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export type AuthHeader = Input<'PLAIN' | 'BEARER'>;
    // @ts-ignore
    export interface DirectHttpResponse {
      // HTTP response body.
      // @ts-ignore
      body?: Input<string>;
      // @ts-ignore
      code?: Input<HttpStatusCode>;
      // HTTP response headers.
      // @ts-ignore
      headers?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export type HttpStatusCode = Input<
      | 'Empty'
      | 'Continue'
      | 'OK'
      | 'Created'
      | 'Accepted'
      | 'NonAuthoritativeInformation'
      | 'NoContent'
      | 'ResetContent'
      | 'PartialContent'
      | 'MultiStatus'
      | 'AlreadyReported'
      | 'IMUsed'
      | 'MultipleChoices'
      | 'MovedPermanently'
      | 'Found'
      | 'SeeOther'
      | 'NotModified'
      | 'UseProxy'
      | 'TemporaryRedirect'
      | 'PermanentRedirect'
      | 'BadRequest'
      | 'Unauthorized'
      | 'PaymentRequired'
      | 'Forbidden'
      | 'NotFound'
      | 'MethodNotAllowed'
      | 'NotAcceptable'
      | 'ProxyAuthenticationRequired'
      | 'RequestTimeout'
      | 'Conflict'
      | 'Gone'
      | 'LengthRequired'
      | 'PreconditionFailed'
      | 'PayloadTooLarge'
      | 'URITooLong'
      | 'UnsupportedMediaType'
      | 'RangeNotSatisfiable'
      | 'ExpectationFailed'
      | 'MisdirectedRequest'
      | 'UnprocessableEntity'
      | 'Locked'
      | 'FailedDependency'
      | 'UpgradeRequired'
      | 'PreconditionRequired'
      | 'TooManyRequests'
      | 'RequestHeaderFieldsTooLarge'
      | 'InternalServerError'
      | 'NotImplemented'
      | 'BadGateway'
      | 'ServiceUnavailable'
      | 'GatewayTimeout'
      | 'HTTPVersionNotSupported'
      | 'VariantAlsoNegotiates'
      | 'InsufficientStorage'
      | 'LoopDetected'
      | 'NotExtended'
      | 'NetworkAuthenticationRequired'
    >;
    // @ts-ignore
    export interface IPAddress {
      // IPAddress encoded as bytes.
      // @ts-ignore
      value?: Input<string>;
    }
    // @ts-ignore
    export interface TimeStamp {
      // TimeStamp encoded as google.protobuf.Timestamp.
      // @ts-ignore
      value?: Input<string>;
    }
    // @ts-ignore
    export interface EmailAddress {
      // EmailAddress encoded as string.
      // @ts-ignore
      value?: Input<string>;
    }
    // @ts-ignore
    export interface DNSName {
      // DNSName encoded as string.
      // @ts-ignore
      value?: Input<string>;
    }
    // @ts-ignore
    export interface Uri {
      // Uri encoded as string.
      // @ts-ignore
      value?: Input<string>;
    }
    // @ts-ignore
    export interface StringMap {
      // StringMap encoded as a map of strings
      // @ts-ignore
      value?: Input<Record<Input<string>, Input<string>>>;
    }
  }
}

export namespace security {
  export namespace v1beta1 {
    // @ts-ignore
    export interface AuthorizationPolicy {
      // @ts-ignore
      selector?: Input<WorkloadSelector>;
      // Optional. A list of rules to match the request. A match occurs when at least one rule matches the request.
      // @ts-ignore
      rules?: Input<Input<Rule>[]>;
      // @ts-ignore
      action?: Input<Action>;
    }
    export interface RuleArgs {
      metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
      spec: Input<Rule>;
    }
    // @ts-ignore
    export interface Rule {
      // Optional. from specifies the source of a request.
      // @ts-ignore
      from?: Input<Input<From>[]>;
      // Optional. to specifies the operation of a request.
      // @ts-ignore
      to?: Input<Input<To>[]>;
      // Optional. when specifies a list of additional conditions of a request.
      // @ts-ignore
      when?: Input<Input<Condition>[]>;
    }
    // @ts-ignore
    export type Action = Input<'ALLOW' | 'DENY'>;
    // @ts-ignore
    export interface From {
      // @ts-ignore
      source?: Input<Source>;
    }
    // @ts-ignore
    export interface To {
      // @ts-ignore
      operation?: Input<Operation>;
    }
    // @ts-ignore
    export interface Condition {
      // The name of an Istio attribute. See the [full list of supported attributes](https://istio.io/docs/reference/config/security/conditions/).
      // @ts-ignore
      key?: Input<string>;
      // Optional. A list of allowed values for the attribute. Note: at least one of values or not_values must be set.
      // @ts-ignore
      values?: Input<Input<string>[]>;
      // Optional. A list of negative match of values for the attribute. Note: at least one of values or not_values must be set.
      // @ts-ignore
      notValues?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export interface Source {
      // Optional. A list of source peer identities (i.e. service account), which matches to the "source.principal" attribute. This field requires mTLS enabled.
      // @ts-ignore
      principals?: Input<Input<string>[]>;
      // Optional. A list of negative match of source peer identities.
      // @ts-ignore
      notPrincipals?: Input<Input<string>[]>;
      // Optional. A list of request identities (i.e. "iss/sub" claims), which matches to the "request.auth.principal" attribute.
      // @ts-ignore
      requestPrincipals?: Input<Input<string>[]>;
      // Optional. A list of negative match of request identities.
      // @ts-ignore
      notRequestPrincipals?: Input<Input<string>[]>;
      // Optional. A list of namespaces, which matches to the "source.namespace" attribute. This field requires mTLS enabled.
      // @ts-ignore
      namespaces?: Input<Input<string>[]>;
      // Optional. A list of negative match of namespaces.
      // @ts-ignore
      notNamespaces?: Input<Input<string>[]>;
      // Optional. A list of IP blocks, which matches to the "source.ip" attribute. Single IP (e.g. "1.2.3.4") and CIDR (e.g. "1.2.3.0/24") are supported.
      // @ts-ignore
      ipBlocks?: Input<Input<string>[]>;
      // Optional. A list of negative match of IP blocks.
      // @ts-ignore
      notIpBlocks?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export interface Operation {
      // Optional. A list of hosts, which matches to the "request.host" attribute.
      // @ts-ignore
      hosts?: Input<Input<string>[]>;
      // Optional. A list of negative match of hosts.
      // @ts-ignore
      notHosts?: Input<Input<string>[]>;
      // Optional. A list of ports, which matches to the "destination.port" attribute.
      // @ts-ignore
      ports?: Input<Input<string>[]>;
      // Optional. A list of negative match of ports.
      // @ts-ignore
      notPorts?: Input<Input<string>[]>;
      // Optional. A list of methods, which matches to the "request.method" attribute. For gRPC service, this will always be "POST".
      // @ts-ignore
      methods?: Input<Input<string>[]>;
      // Optional. A list of negative match of methods.
      // @ts-ignore
      notMethods?: Input<Input<string>[]>;
      // Optional. A list of paths, which matches to the "request.url_path" attribute. For gRPC service, this will be the fully-qualified name in the form of "/package.service/method".
      // @ts-ignore
      paths?: Input<Input<string>[]>;
      // Optional. A list of negative match of paths.
      // @ts-ignore
      notPaths?: Input<Input<string>[]>;
    }
    // @ts-ignore
    export interface WorkloadSelector {
      // One or more labels that indicate a specific set of pods/VMs on which a policy should be applied. The scope of label search is restricted to the configuration namespace in which the resource is present.
      // @ts-ignore
      matchLabels?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export interface JWTRule {
      // Identifies the issuer that issued the JWT. See [issuer](https://tools.ietf.org/html/rfc7519#section-4.1.1) A JWT with different `iss` claim will be rejected.
      // @ts-ignore
      issuer?: Input<string>;
      // The list of JWT [audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3). that are allowed to access. A JWT containing any of these audiences will be accepted.
      // @ts-ignore
      audiences?: Input<Input<string>[]>;
      // URL of the provider's public key set to validate signature of the JWT. See [OpenID Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
      // @ts-ignore
      jwksUri?: Input<string>;
      // JSON Web Key Set of public keys to validate signature of the JWT. See https://auth0.com/docs/jwks.
      // @ts-ignore
      jwks?: Input<string>;
      // List of header locations from which JWT is expected. For example, below is the location spec if JWT is expected to be found in `x-jwt-assertion` header, and have "Bearer " prefix: ``` fromHeaders: - name: x-jwt-assertion prefix: "Bearer " ```
      // @ts-ignore
      fromHeaders?: Input<Input<JWTHeader>[]>;
      // List of query parameters from which JWT is expected. For example, if JWT is provided via query parameter `my_token` (e.g /path?my_token=<JWT>), the config is: ``` fromParams: - "my_token" ```
      // @ts-ignore
      fromParams?: Input<Input<string>[]>;
      // This field specifies the header name to output a successfully verified JWT payload to the backend. The forwarded data is `base64_encoded(jwt_payload_in_JSON)`. If it is not specified, the payload will not be emitted.
      // @ts-ignore
      outputPayloadToHeader?: Input<string>;
      // If set to true, the orginal token will be kept for the ustream request. Default is false.
      // @ts-ignore
      forwardOriginalToken?: Input<boolean>;
    }
    // @ts-ignore
    export interface JWTHeader {
      // The HTTP header name.
      // @ts-ignore
      name?: Input<string>;
      // The prefix that should be stripped before decoding the token. For example, for "Authorization: Bearer <token>", prefix="Bearer " with a space at the end. If the header doesn't have this exact prefix, it is considerred invalid.
      // @ts-ignore
      prefix?: Input<string>;
    }
    // @ts-ignore
    export interface PeerAuthentication {
      // @ts-ignore
      selector?: Input<WorkloadSelector>;
      // @ts-ignore
      mtls?: Input<MutualTLS>;
      // Port specific mutual TLS settings.
      // @ts-ignore
      portLevelMtls?: Input<Record<Input<string>, Input<MutualTLS>>>;
    }
    // @ts-ignore
    export interface MutualTLS {
      // @ts-ignore
      mode?: Input<Mode>;
    }
    // @ts-ignore
    export type Mode = Input<'UNSET' | 'DISABLE' | 'PERMISSIVE' | 'STRICT'>;
    // @ts-ignore
    export interface WorkloadSelector {
      // One or more labels that indicate a specific set of pods/VMs on which a policy should be applied. The scope of label search is restricted to the configuration namespace in which the resource is present.
      // @ts-ignore
      matchLabels?: Input<Record<Input<string>, Input<string>>>;
    }
    // @ts-ignore
    export interface JWTRule {
      // Identifies the issuer that issued the JWT. See [issuer](https://tools.ietf.org/html/rfc7519#section-4.1.1) A JWT with different `iss` claim will be rejected.
      // @ts-ignore
      issuer?: Input<string>;
      // The list of JWT [audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3). that are allowed to access. A JWT containing any of these audiences will be accepted.
      // @ts-ignore
      audiences?: Input<Input<string>[]>;
      // URL of the provider's public key set to validate signature of the JWT. See [OpenID Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
      // @ts-ignore
      jwksUri?: Input<string>;
      // JSON Web Key Set of public keys to validate signature of the JWT. See https://auth0.com/docs/jwks.
      // @ts-ignore
      jwks?: Input<string>;
      // List of header locations from which JWT is expected. For example, below is the location spec if JWT is expected to be found in `x-jwt-assertion` header, and have "Bearer " prefix: ``` fromHeaders: - name: x-jwt-assertion prefix: "Bearer " ```
      // @ts-ignore
      fromHeaders?: Input<Input<JWTHeader>[]>;
      // List of query parameters from which JWT is expected. For example, if JWT is provided via query parameter `my_token` (e.g /path?my_token=<JWT>), the config is: ``` fromParams: - "my_token" ```
      // @ts-ignore
      fromParams?: Input<Input<string>[]>;
      // This field specifies the header name to output a successfully verified JWT payload to the backend. The forwarded data is `base64_encoded(jwt_payload_in_JSON)`. If it is not specified, the payload will not be emitted.
      // @ts-ignore
      outputPayloadToHeader?: Input<string>;
      // If set to true, the orginal token will be kept for the ustream request. Default is false.
      // @ts-ignore
      forwardOriginalToken?: Input<boolean>;
    }
    // @ts-ignore
    export interface JWTHeader {
      // The HTTP header name.
      // @ts-ignore
      name?: Input<string>;
      // The prefix that should be stripped before decoding the token. For example, for "Authorization: Bearer <token>", prefix="Bearer " with a space at the end. If the header doesn't have this exact prefix, it is considerred invalid.
      // @ts-ignore
      prefix?: Input<string>;
    }
    // @ts-ignore
    export interface RequestAuthentication {
      // @ts-ignore
      selector?: Input<WorkloadSelector>;
      // Define the list of JWTs that can be validated at the selected workloads' proxy. A valid token will be used to extract the authenticated identity. Each rule will be activated only when a token is presented at the location recorgnized by the rule. The token will be validated based on the JWT rule config. If validation fails, the request will be rejected. Note: if more than one token is presented (at different locations), the output principal is nondeterministic.
      // @ts-ignore
      jwtRules?: Input<Input<JWTRule>[]>;
    }
    // @ts-ignore
    export interface WorkloadSelector {
      // One or more labels that indicate a specific set of pods/VMs on which a policy should be applied. The scope of label search is restricted to the configuration namespace in which the resource is present.
      // @ts-ignore
      matchLabels?: Input<Record<Input<string>, Input<string>>>;
    }
  }
}

export namespace type {
  export namespace v1beta1 {
    // @ts-ignore
    export interface WorkloadSelector {
      // One or more labels that indicate a specific set of pods/VMs on which a policy should be applied. The scope of label search is restricted to the configuration namespace in which the resource is present.
      // @ts-ignore
      matchLabels?: Input<Record<Input<string>, Input<string>>>;
    }
  }
}
